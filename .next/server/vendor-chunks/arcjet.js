"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/arcjet";
exports.ids = ["vendor-chunks/arcjet"];
exports.modules = {

/***/ "(rsc)/./node_modules/arcjet/index.js":
/*!**************************************!*\
  !*** ./node_modules/arcjet/index.js ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ArcjetAllowDecision: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetAllowDecision),\n/* harmony export */   ArcjetBotReason: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetBotReason),\n/* harmony export */   ArcjetChallengeDecision: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetChallengeDecision),\n/* harmony export */   ArcjetConclusion: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetConclusion),\n/* harmony export */   ArcjetDecision: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetDecision),\n/* harmony export */   ArcjetDenyDecision: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetDenyDecision),\n/* harmony export */   ArcjetEdgeRuleReason: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetEdgeRuleReason),\n/* harmony export */   ArcjetEmailReason: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetEmailReason),\n/* harmony export */   ArcjetEmailType: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetEmailType),\n/* harmony export */   ArcjetErrorDecision: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetErrorDecision),\n/* harmony export */   ArcjetErrorReason: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetErrorReason),\n/* harmony export */   ArcjetIpDetails: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetIpDetails),\n/* harmony export */   ArcjetMode: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetMode),\n/* harmony export */   ArcjetRateLimitAlgorithm: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRateLimitAlgorithm),\n/* harmony export */   ArcjetRateLimitReason: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRateLimitReason),\n/* harmony export */   ArcjetReason: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetReason),\n/* harmony export */   ArcjetRuleResult: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleResult),\n/* harmony export */   ArcjetRuleState: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleState),\n/* harmony export */   ArcjetRuleType: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleType),\n/* harmony export */   ArcjetSensitiveInfoReason: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetSensitiveInfoReason),\n/* harmony export */   ArcjetSensitiveInfoType: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetSensitiveInfoType),\n/* harmony export */   ArcjetShieldReason: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetShieldReason),\n/* harmony export */   ArcjetStack: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetStack),\n/* harmony export */   botCategories: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.botCategories),\n/* harmony export */   \"default\": () => (/* binding */ arcjet),\n/* harmony export */   detectBot: () => (/* binding */ detectBot),\n/* harmony export */   fixedWindow: () => (/* binding */ fixedWindow),\n/* harmony export */   protectSignup: () => (/* binding */ protectSignup),\n/* harmony export */   sensitiveInfo: () => (/* binding */ sensitiveInfo),\n/* harmony export */   shield: () => (/* binding */ shield),\n/* harmony export */   slidingWindow: () => (/* binding */ slidingWindow),\n/* harmony export */   tokenBucket: () => (/* binding */ tokenBucket),\n/* harmony export */   validateEmail: () => (/* binding */ validateEmail)\n/* harmony export */ });\n/* harmony import */ var _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @arcjet/protocol */ \"(rsc)/./node_modules/@arcjet/protocol/index.js\");\n/* harmony import */ var _arcjet_protocol_convert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @arcjet/protocol/convert.js */ \"(rsc)/./node_modules/@arcjet/protocol/convert.js\");\n/* harmony import */ var _arcjet_analyze__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @arcjet/analyze */ \"(rsc)/./node_modules/@arcjet/analyze/index.js\");\n/* harmony import */ var _arcjet_duration__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @arcjet/duration */ \"(rsc)/./node_modules/@arcjet/duration/index.js\");\n/* harmony import */ var _arcjet_headers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @arcjet/headers */ \"(rsc)/./node_modules/@arcjet/headers/index.js\");\n/* harmony import */ var _arcjet_runtime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @arcjet/runtime */ \"(rsc)/./node_modules/@arcjet/runtime/index.js\");\n\n\n\n\n\n\n\n\nfunction assert(condition, msg) {\n    if (!condition) {\n        throw new Error(msg);\n    }\n}\nfunction nowInSeconds() {\n    return Math.floor(Date.now() / 1000);\n}\nclass Cache {\n    expires;\n    data;\n    constructor() {\n        this.expires = new Map();\n        this.data = new Map();\n    }\n    get(key) {\n        const ttl = this.ttl(key);\n        if (ttl > 0) {\n            return this.data.get(key);\n        }\n        else {\n            // Cleanup if expired\n            this.expires.delete(key);\n            this.data.delete(key);\n        }\n    }\n    set(key, value, expiresAt) {\n        this.expires.set(key, expiresAt);\n        this.data.set(key, value);\n    }\n    ttl(key) {\n        const now = nowInSeconds();\n        const expiresAt = this.expires.get(key) ?? now;\n        return expiresAt - now;\n    }\n}\nfunction errorMessage(err) {\n    if (err) {\n        if (typeof err === \"string\") {\n            return err;\n        }\n        if (typeof err === \"object\" &&\n            \"message\" in err &&\n            typeof err.message === \"string\") {\n            return err.message;\n        }\n    }\n    return \"Unknown problem\";\n}\nconst knownFields = [\n    \"ip\",\n    \"method\",\n    \"protocol\",\n    \"host\",\n    \"path\",\n    \"headers\",\n    \"body\",\n    \"email\",\n    \"cookies\",\n    \"query\",\n];\nfunction isUnknownRequestProperty(key) {\n    return !knownFields.includes(key);\n}\nfunction isEmailType(type) {\n    return (type === \"FREE\" ||\n        type === \"DISPOSABLE\" ||\n        type === \"NO_MX_RECORDS\" ||\n        type === \"NO_GRAVATAR\" ||\n        type === \"INVALID\");\n}\nclass Performance {\n    log;\n    constructor(logger) {\n        this.log = logger;\n    }\n    // TODO(#2020): We should no-op this if loglevel is not `debug` to do less work\n    measure(label) {\n        const start = performance.now();\n        return () => {\n            const end = performance.now();\n            const diff = end - start;\n            this.log.debug(\"LATENCY %s: %sms\", label, diff.toFixed(3));\n        };\n    }\n}\nfunction toString(value) {\n    if (typeof value === \"string\") {\n        return value;\n    }\n    if (typeof value === \"number\") {\n        return `${value}`;\n    }\n    if (typeof value === \"boolean\") {\n        return value ? \"true\" : \"false\";\n    }\n    return \"<unsupported value>\";\n}\n// This is the Symbol that Vercel defines in their infrastructure to access the\n// Context (where available). The Context can contain the `waitUntil` function.\n// https://github.com/vercel/vercel/blob/930d7fb892dc26f240f2b950d963931c45e1e661/packages/functions/src/get-context.ts#L6\nconst SYMBOL_FOR_REQ_CONTEXT = Symbol.for(\"@vercel/request-context\");\nfunction lookupWaitUntil() {\n    const fromSymbol = globalThis;\n    if (typeof fromSymbol[SYMBOL_FOR_REQ_CONTEXT] === \"object\" &&\n        fromSymbol[SYMBOL_FOR_REQ_CONTEXT] !== null &&\n        \"get\" in fromSymbol[SYMBOL_FOR_REQ_CONTEXT] &&\n        typeof fromSymbol[SYMBOL_FOR_REQ_CONTEXT].get === \"function\") {\n        const vercelCtx = fromSymbol[SYMBOL_FOR_REQ_CONTEXT].get();\n        if (typeof vercelCtx === \"object\" &&\n            vercelCtx !== null &&\n            \"waitUntil\" in vercelCtx &&\n            typeof vercelCtx.waitUntil === \"function\") {\n            return vercelCtx.waitUntil;\n        }\n    }\n}\nfunction toAnalyzeRequest(request) {\n    const headers = {};\n    if (typeof request.headers !== \"undefined\") {\n        for (const [key, value] of request.headers.entries()) {\n            headers[key] = value;\n        }\n    }\n    return {\n        ...request,\n        headers,\n    };\n}\nfunction extraProps(details) {\n    const extra = new Map();\n    for (const [key, value] of Object.entries(details)) {\n        if (isUnknownRequestProperty(key)) {\n            extra.set(key, toString(value));\n        }\n    }\n    return Object.fromEntries(extra.entries());\n}\nfunction createTypeValidator(...types) {\n    return (key, value) => {\n        const typeOfValue = typeof value;\n        if (!types.includes(typeOfValue)) {\n            if (types.length === 1) {\n                throw new Error(`invalid type for \\`${key}\\` - expected ${types[0]}`);\n            }\n            else {\n                throw new Error(`invalid type for \\`${key}\\` - expected one of ${types.join(\", \")}`);\n            }\n        }\n        else {\n            return false;\n        }\n    };\n}\nfunction createValueValidator(\n// This uses types to ensure we have at least 2 values\n...values) {\n    return (key, value) => {\n        // We cast the values to unknown because the optionValue isn't known but\n        // we only want to use `values` on string enumerations\n        if (!values.includes(value)) {\n            throw new Error(`invalid value for \\`${key}\\` - expected one of ${values.map((value) => `'${value}'`).join(\", \")}`);\n        }\n    };\n}\nfunction createArrayValidator(validate) {\n    return (key, value) => {\n        if (Array.isArray(value)) {\n            for (const [idx, item] of value.entries()) {\n                validate(`${key}[${idx}]`, item);\n            }\n        }\n        else {\n            throw new Error(`invalid type for \\`${key}\\` - expected an array`);\n        }\n    };\n}\nfunction createValidator({ rule, validations, }) {\n    return (options) => {\n        for (const { key, validate, required } of validations) {\n            if (required && !Object.hasOwn(options, key)) {\n                throw new Error(`\\`${rule}\\` options error: \\`${key}\\` is required`);\n            }\n            const value = options[key];\n            // The `required` flag is checked above, so these should only be validated\n            // if the value is not undefined.\n            if (typeof value !== \"undefined\") {\n                try {\n                    validate(key, value);\n                }\n                catch (err) {\n                    throw new Error(`\\`${rule}\\` options error: ${errorMessage(err)}`);\n                }\n            }\n        }\n    };\n}\nconst validateString = createTypeValidator(\"string\");\nconst validateNumber = createTypeValidator(\"number\");\nconst validateBoolean = createTypeValidator(\"boolean\");\nconst validateFunction = createTypeValidator(\"function\");\nconst validateStringOrNumber = createTypeValidator(\"string\", \"number\");\nconst validateStringArray = createArrayValidator(validateString);\nconst validateMode = createValueValidator(\"LIVE\", \"DRY_RUN\");\nconst validateEmailTypes = createArrayValidator(createValueValidator(\"DISPOSABLE\", \"FREE\", \"NO_MX_RECORDS\", \"NO_GRAVATAR\", \"INVALID\"));\nconst validateTokenBucketOptions = createValidator({\n    rule: \"tokenBucket\",\n    validations: [\n        {\n            key: \"mode\",\n            required: false,\n            validate: validateMode,\n        },\n        {\n            key: \"characteristics\",\n            validate: validateStringArray,\n            required: false,\n        },\n        { key: \"refillRate\", required: true, validate: validateNumber },\n        { key: \"interval\", required: true, validate: validateStringOrNumber },\n        { key: \"capacity\", required: true, validate: validateNumber },\n    ],\n});\nconst validateFixedWindowOptions = createValidator({\n    rule: \"fixedWindow\",\n    validations: [\n        { key: \"mode\", required: false, validate: validateMode },\n        {\n            key: \"characteristics\",\n            validate: validateStringArray,\n            required: false,\n        },\n        { key: \"max\", required: true, validate: validateNumber },\n        { key: \"window\", required: true, validate: validateStringOrNumber },\n    ],\n});\nconst validateSlidingWindowOptions = createValidator({\n    rule: \"slidingWindow\",\n    validations: [\n        { key: \"mode\", required: false, validate: validateMode },\n        {\n            key: \"characteristics\",\n            validate: validateStringArray,\n            required: false,\n        },\n        { key: \"max\", required: true, validate: validateNumber },\n        { key: \"interval\", required: true, validate: validateStringOrNumber },\n    ],\n});\nconst validateSensitiveInfoOptions = createValidator({\n    rule: \"sensitiveInfo\",\n    validations: [\n        { key: \"mode\", required: false, validate: validateMode },\n        { key: \"allow\", required: false, validate: validateStringArray },\n        { key: \"deny\", required: false, validate: validateStringArray },\n        { key: \"contextWindowSize\", required: false, validate: validateNumber },\n        { key: \"detect\", required: false, validate: validateFunction },\n    ],\n});\nconst validateEmailOptions = createValidator({\n    rule: \"validateEmail\",\n    validations: [\n        { key: \"mode\", required: false, validate: validateMode },\n        { key: \"block\", required: false, validate: validateEmailTypes },\n        {\n            key: \"requireTopLevelDomain\",\n            required: false,\n            validate: validateBoolean,\n        },\n        { key: \"allowDomainLiteral\", required: false, validate: validateBoolean },\n    ],\n});\nconst validateBotOptions = createValidator({\n    rule: \"detectBot\",\n    validations: [\n        { key: \"mode\", required: false, validate: validateMode },\n        { key: \"allow\", required: false, validate: validateStringArray },\n        { key: \"deny\", required: false, validate: validateStringArray },\n    ],\n});\nconst validateShieldOptions = createValidator({\n    rule: \"shield\",\n    validations: [{ key: \"mode\", required: false, validate: validateMode }],\n});\nconst Priority = {\n    SensitiveInfo: 1,\n    Shield: 2,\n    RateLimit: 3,\n    BotDetection: 4,\n    EmailValidation: 5,\n};\nfunction isLocalRule(rule) {\n    return (\"validate\" in rule &&\n        typeof rule.validate === \"function\" &&\n        \"protect\" in rule &&\n        typeof rule.protect === \"function\");\n}\nfunction tokenBucket(options) {\n    validateTokenBucketOptions(options);\n    const mode = options.mode === \"LIVE\" ? \"LIVE\" : \"DRY_RUN\";\n    const characteristics = options.characteristics;\n    const refillRate = options.refillRate;\n    const interval = _arcjet_duration__WEBPACK_IMPORTED_MODULE_3__.parse(options.interval);\n    const capacity = options.capacity;\n    return [\n        {\n            type: \"RATE_LIMIT\",\n            priority: Priority.RateLimit,\n            mode,\n            characteristics,\n            algorithm: \"TOKEN_BUCKET\",\n            refillRate,\n            interval,\n            capacity,\n        },\n    ];\n}\nfunction fixedWindow(options) {\n    validateFixedWindowOptions(options);\n    const mode = options.mode === \"LIVE\" ? \"LIVE\" : \"DRY_RUN\";\n    const characteristics = Array.isArray(options.characteristics)\n        ? options.characteristics\n        : undefined;\n    const max = options.max;\n    const window = _arcjet_duration__WEBPACK_IMPORTED_MODULE_3__.parse(options.window);\n    return [\n        {\n            type: \"RATE_LIMIT\",\n            priority: Priority.RateLimit,\n            mode,\n            characteristics,\n            algorithm: \"FIXED_WINDOW\",\n            max,\n            window,\n        },\n    ];\n}\nfunction slidingWindow(options) {\n    validateSlidingWindowOptions(options);\n    const mode = options.mode === \"LIVE\" ? \"LIVE\" : \"DRY_RUN\";\n    const characteristics = Array.isArray(options.characteristics)\n        ? options.characteristics\n        : undefined;\n    const max = options.max;\n    const interval = _arcjet_duration__WEBPACK_IMPORTED_MODULE_3__.parse(options.interval);\n    return [\n        {\n            type: \"RATE_LIMIT\",\n            priority: Priority.RateLimit,\n            mode,\n            characteristics,\n            algorithm: \"SLIDING_WINDOW\",\n            max,\n            interval,\n        },\n    ];\n}\nfunction protocolSensitiveInfoEntitiesToAnalyze(entity) {\n    if (typeof entity !== \"string\") {\n        throw new Error(\"invalid entity type\");\n    }\n    if (entity === \"EMAIL\") {\n        return { tag: \"email\" };\n    }\n    if (entity === \"PHONE_NUMBER\") {\n        return { tag: \"phone-number\" };\n    }\n    if (entity === \"IP_ADDRESS\") {\n        return { tag: \"ip-address\" };\n    }\n    if (entity === \"CREDIT_CARD_NUMBER\") {\n        return { tag: \"credit-card-number\" };\n    }\n    return {\n        tag: \"custom\",\n        val: entity,\n    };\n}\nfunction analyzeSensitiveInfoEntitiesToString(entity) {\n    if (entity.tag === \"email\") {\n        return \"EMAIL\";\n    }\n    if (entity.tag === \"ip-address\") {\n        return \"IP_ADDRESS\";\n    }\n    if (entity.tag === \"credit-card-number\") {\n        return \"CREDIT_CARD_NUMBER\";\n    }\n    if (entity.tag === \"phone-number\") {\n        return \"PHONE_NUMBER\";\n    }\n    return entity.val;\n}\nfunction convertAnalyzeDetectedSensitiveInfoEntity(detectedEntities) {\n    return detectedEntities.map((detectedEntity) => {\n        return {\n            ...detectedEntity,\n            identifiedType: analyzeSensitiveInfoEntitiesToString(detectedEntity.identifiedType),\n        };\n    });\n}\nfunction sensitiveInfo(options) {\n    validateSensitiveInfoOptions(options);\n    const mode = options.mode === \"LIVE\" ? \"LIVE\" : \"DRY_RUN\";\n    if (typeof options.allow !== \"undefined\" &&\n        typeof options.deny !== \"undefined\") {\n        throw new Error(\"`sensitiveInfo` options error: `allow` and `deny` cannot be provided together\");\n    }\n    if (typeof options.allow === \"undefined\" &&\n        typeof options.deny === \"undefined\") {\n        throw new Error(\"`sensitiveInfo` options error: either `allow` or `deny` must be specified\");\n    }\n    return [\n        {\n            type: \"SENSITIVE_INFO\",\n            priority: Priority.SensitiveInfo,\n            mode,\n            allow: options.allow || [],\n            deny: options.deny || [],\n            validate(context, details) { },\n            async protect(context, details) {\n                const body = await context.getBody();\n                if (typeof body === \"undefined\") {\n                    return new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleResult({\n                        ttl: 0,\n                        state: \"NOT_RUN\",\n                        conclusion: \"ERROR\",\n                        reason: new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetErrorReason(\"Couldn't read the body of the request to perform sensitive info identification.\"),\n                    });\n                }\n                let convertedDetect = undefined;\n                if (typeof options.detect !== \"undefined\") {\n                    const detect = options.detect;\n                    convertedDetect = (tokens) => {\n                        return detect(tokens)\n                            .filter((e) => typeof e !== \"undefined\")\n                            .map(protocolSensitiveInfoEntitiesToAnalyze);\n                    };\n                }\n                let entitiesTag = \"allow\";\n                let entitiesVal = [];\n                if (Array.isArray(options.allow)) {\n                    entitiesTag = \"allow\";\n                    entitiesVal = options.allow\n                        .filter((e) => typeof e !== \"undefined\")\n                        .map(protocolSensitiveInfoEntitiesToAnalyze);\n                }\n                if (Array.isArray(options.deny)) {\n                    entitiesTag = \"deny\";\n                    entitiesVal = options.deny\n                        .filter((e) => typeof e !== \"undefined\")\n                        .map(protocolSensitiveInfoEntitiesToAnalyze);\n                }\n                const entities = {\n                    tag: entitiesTag,\n                    val: entitiesVal,\n                };\n                const result = await _arcjet_analyze__WEBPACK_IMPORTED_MODULE_2__.detectSensitiveInfo(context, body, entities, options.contextWindowSize || 1, convertedDetect);\n                const reason = new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetSensitiveInfoReason({\n                    denied: convertAnalyzeDetectedSensitiveInfoEntity(result.denied),\n                    allowed: convertAnalyzeDetectedSensitiveInfoEntity(result.allowed),\n                });\n                if (result.denied.length === 0) {\n                    return new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleResult({\n                        ttl: 0,\n                        state: \"RUN\",\n                        conclusion: \"ALLOW\",\n                        reason,\n                    });\n                }\n                else {\n                    return new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleResult({\n                        ttl: 0,\n                        state: \"RUN\",\n                        conclusion: \"DENY\",\n                        reason,\n                    });\n                }\n            },\n        },\n    ];\n}\nfunction validateEmail(options) {\n    validateEmailOptions(options);\n    const mode = options.mode === \"LIVE\" ? \"LIVE\" : \"DRY_RUN\";\n    const block = options.block ?? [];\n    const requireTopLevelDomain = options.requireTopLevelDomain ?? true;\n    const allowDomainLiteral = options.allowDomainLiteral ?? false;\n    const emailOpts = {\n        requireTopLevelDomain,\n        allowDomainLiteral,\n        blockedEmails: block,\n    };\n    return [\n        {\n            type: \"EMAIL\",\n            priority: Priority.EmailValidation,\n            mode,\n            block,\n            requireTopLevelDomain,\n            allowDomainLiteral,\n            validate(context, details) {\n                assert(typeof details.email !== \"undefined\", \"ValidateEmail requires `email` to be set.\");\n            },\n            async protect(context, { email }) {\n                const result = await _arcjet_analyze__WEBPACK_IMPORTED_MODULE_2__.isValidEmail(context, email, emailOpts);\n                if (result.validity === \"valid\") {\n                    return new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleResult({\n                        ttl: 0,\n                        state: \"RUN\",\n                        conclusion: \"ALLOW\",\n                        reason: new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetEmailReason({ emailTypes: [] }),\n                    });\n                }\n                else {\n                    const typedEmailTypes = result.blocked.filter(isEmailType);\n                    return new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleResult({\n                        ttl: 0,\n                        state: \"RUN\",\n                        conclusion: \"DENY\",\n                        reason: new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetEmailReason({\n                            emailTypes: typedEmailTypes,\n                        }),\n                    });\n                }\n            },\n        },\n    ];\n}\nfunction detectBot(options) {\n    validateBotOptions(options);\n    const mode = options.mode === \"LIVE\" ? \"LIVE\" : \"DRY_RUN\";\n    if (typeof options.allow !== \"undefined\" &&\n        typeof options.deny !== \"undefined\") {\n        throw new Error(\"`detectBot` options error: `allow` and `deny` cannot be provided together\");\n    }\n    if (typeof options.allow === \"undefined\" &&\n        typeof options.deny === \"undefined\") {\n        throw new Error(\"`detectBot` options error: either `allow` or `deny` must be specified\");\n    }\n    let config = {\n        tag: \"allowed-bot-config\",\n        val: {\n            entities: [],\n            skipCustomDetect: true,\n        },\n    };\n    if (typeof options.allow !== \"undefined\") {\n        config = {\n            tag: \"allowed-bot-config\",\n            val: {\n                entities: options.allow,\n                skipCustomDetect: true,\n            },\n        };\n    }\n    if (typeof options.deny !== \"undefined\") {\n        config = {\n            tag: \"denied-bot-config\",\n            val: {\n                entities: options.deny,\n                skipCustomDetect: true,\n            },\n        };\n    }\n    return [\n        {\n            type: \"BOT\",\n            priority: Priority.BotDetection,\n            mode,\n            allow: options.allow ?? [],\n            deny: options.deny ?? [],\n            validate(context, details) {\n                if (typeof details.headers === \"undefined\") {\n                    throw new Error(\"bot detection requires `headers` to be set\");\n                }\n                if (typeof details.headers.has !== \"function\") {\n                    throw new Error(\"bot detection requires `headers` to extend `Headers`\");\n                }\n                if (!details.headers.has(\"user-agent\")) {\n                    throw new Error(\"bot detection requires user-agent header\");\n                }\n            },\n            /**\n             * Attempts to call the bot detection on the headers.\n             */\n            async protect(context, request) {\n                const result = await _arcjet_analyze__WEBPACK_IMPORTED_MODULE_2__.detectBot(context, toAnalyzeRequest(request), config);\n                // If this is a bot and of a type that we want to block, then block!\n                if (result.denied.length > 0) {\n                    return new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleResult({\n                        ttl: 60,\n                        state: \"RUN\",\n                        conclusion: \"DENY\",\n                        reason: new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetBotReason({\n                            allowed: result.allowed,\n                            denied: result.denied,\n                            verified: result.verified,\n                            spoofed: result.spoofed,\n                        }),\n                    });\n                }\n                else {\n                    return new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleResult({\n                        ttl: 0,\n                        state: \"RUN\",\n                        conclusion: \"ALLOW\",\n                        reason: new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetBotReason({\n                            allowed: result.allowed,\n                            denied: result.denied,\n                            verified: result.verified,\n                            spoofed: result.spoofed,\n                        }),\n                    });\n                }\n            },\n        },\n    ];\n}\nfunction shield(options) {\n    validateShieldOptions(options);\n    const mode = options.mode === \"LIVE\" ? \"LIVE\" : \"DRY_RUN\";\n    return [\n        {\n            type: \"SHIELD\",\n            priority: Priority.Shield,\n            mode,\n        },\n    ];\n}\nfunction protectSignup(options) {\n    return [\n        ...slidingWindow(options.rateLimit),\n        ...detectBot(options.bots),\n        ...validateEmail(options.email),\n    ];\n}\n/**\n * Create a new Arcjet client with the specified {@link ArcjetOptions}.\n *\n * @param options {ArcjetOptions} Arcjet configuration options.\n */\nfunction arcjet(options) {\n    // We destructure here to make the function signature neat when viewed by consumers\n    const { key, rules } = options;\n    const rt = (0,_arcjet_runtime__WEBPACK_IMPORTED_MODULE_5__.runtime)();\n    // TODO: Separate the ArcjetOptions from the SDK Options\n    // It is currently optional in the options so users can override it via an SDK\n    if (typeof options.log === \"undefined\") {\n        throw new Error(\"Log is required\");\n    }\n    const log = options.log;\n    const perf = new Performance(log);\n    // TODO(#207): Remove this when we can default the transport so client is not required\n    // It is currently optional in the options so the Next SDK can override it for the user\n    if (typeof options.client === \"undefined\") {\n        throw new Error(\"Client is required\");\n    }\n    const client = options.client;\n    // A local cache of block decisions. Might be emphemeral per request,\n    // depending on the way the runtime works, but it's worth a try.\n    // TODO(#132): Support configurable caching\n    const blockCache = new Cache();\n    const rootRules = rules\n        .flat(1)\n        .sort((a, b) => a.priority - b.priority);\n    async function protect(rules, ctx, request) {\n        // This goes against the type definition above, but users might call\n        // `protect()` with no value and we don't want to crash\n        if (typeof request === \"undefined\") {\n            request = {};\n        }\n        const details = Object.freeze({\n            ip: request.ip,\n            method: request.method,\n            protocol: request.protocol,\n            host: request.host,\n            path: request.path,\n            headers: new _arcjet_headers__WEBPACK_IMPORTED_MODULE_4__[\"default\"](request.headers),\n            cookies: request.cookies,\n            query: request.query,\n            // TODO(#208): Re-add body\n            // body: request.body,\n            extra: extraProps(request),\n            email: typeof request.email === \"string\" ? request.email : undefined,\n        });\n        const characteristics = options.characteristics\n            ? [...options.characteristics]\n            : [];\n        const waitUntil = lookupWaitUntil();\n        const baseContext = {\n            key,\n            log,\n            characteristics,\n            waitUntil,\n            ...ctx,\n        };\n        let fingerprint = \"\";\n        const logFingerprintPerf = perf.measure(\"fingerprint\");\n        try {\n            fingerprint = await _arcjet_analyze__WEBPACK_IMPORTED_MODULE_2__.generateFingerprint(baseContext, toAnalyzeRequest(details));\n            log.debug(\"fingerprint (%s): %s\", rt, fingerprint);\n        }\n        catch (error) {\n            log.error({ error }, \"Failed to build fingerprint. Please verify your Characteristics.\");\n            const decision = new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetErrorDecision({\n                ttl: 0,\n                reason: new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetErrorReason(`Failed to build fingerprint - ${errorMessage(error)}`),\n                // No results because we couldn't create a fingerprint\n                results: [],\n            });\n            // TODO: Consider sending this to Report when we have an infallible fingerprint\n            return decision;\n        }\n        finally {\n            logFingerprintPerf();\n        }\n        const context = Object.freeze({\n            ...baseContext,\n            fingerprint,\n            runtime: rt,\n        });\n        if (rules.length < 1) {\n            // TODO(#607): Error if no rules configured after deprecation period\n            log.warn(\"Calling `protect()` with no rules is deprecated. Did you mean to configure the Shield rule?\");\n        }\n        if (rules.length > 10) {\n            log.error(\"Failure running rules. Only 10 rules may be specified.\");\n            const decision = new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetErrorDecision({\n                ttl: 0,\n                reason: new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetErrorReason(\"Only 10 rules may be specified\"),\n                // No results because the sorted rules were too long and we don't want\n                // to instantiate a ton of NOT_RUN results\n                results: [],\n            });\n            client.report(context, details, decision, \n            // No rules because we've determined they were too long and we don't\n            // want to try to send them to the server\n            []);\n            return decision;\n        }\n        const results = [];\n        for (let idx = 0; idx < rules.length; idx++) {\n            // Default all rules to NOT_RUN/ALLOW before doing anything\n            results[idx] = new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleResult({\n                ttl: 0,\n                state: \"NOT_RUN\",\n                conclusion: \"ALLOW\",\n                reason: new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetReason(),\n            });\n            // Add top-level characteristics to all Rate Limit rules that don't already have\n            // their own set of characteristics.\n            const candidate_rule = rules[idx];\n            if ((0,_arcjet_protocol_convert_js__WEBPACK_IMPORTED_MODULE_1__.isRateLimitRule)(candidate_rule)) {\n                if (typeof candidate_rule.characteristics === \"undefined\") {\n                    candidate_rule.characteristics = characteristics;\n                    rules[idx] = candidate_rule;\n                }\n            }\n        }\n        const logLocalPerf = perf.measure(\"local\");\n        try {\n            // We have our own local cache which we check first. This doesn't work in\n            // serverless environments where every request is isolated, but there may be\n            // some instances where the instance is not recycled immediately. If so, we\n            // can take advantage of that.\n            const logCachePerf = perf.measure(\"cache\");\n            const existingBlockReason = blockCache.get(fingerprint);\n            logCachePerf();\n            // If already blocked then we can async log to the API and return the\n            // decision immediately.\n            if (existingBlockReason) {\n                const decision = new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetDenyDecision({\n                    ttl: blockCache.ttl(fingerprint),\n                    reason: existingBlockReason,\n                    // All results will be NOT_RUN because we used a cached decision\n                    results,\n                });\n                client.report(context, details, decision, rules);\n                log.debug({\n                    id: decision.id,\n                    conclusion: decision.conclusion,\n                    fingerprint,\n                    reason: existingBlockReason,\n                    runtime: rt,\n                }, \"decide: already blocked\");\n                return decision;\n            }\n            for (const [idx, rule] of rules.entries()) {\n                // This re-assignment is a workaround to a TypeScript error with\n                // assertions where the name was introduced via a destructure\n                let localRule;\n                if (isLocalRule(rule)) {\n                    localRule = rule;\n                }\n                else {\n                    continue;\n                }\n                const logRulePerf = perf.measure(rule.type);\n                try {\n                    localRule.validate(context, details);\n                    results[idx] = await localRule.protect(context, details);\n                    // If a rule didn't return a rule result, we need to stub it to avoid\n                    // crashing. This should only happen if a user writes a custom local\n                    // rule incorrectly.\n                    if (typeof results[idx] === \"undefined\") {\n                        results[idx] = new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleResult({\n                            ttl: 0,\n                            state: \"RUN\",\n                            conclusion: \"ERROR\",\n                            reason: new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetErrorReason(\"rule result missing\"),\n                        });\n                    }\n                    log.debug({\n                        id: results[idx].ruleId,\n                        rule: rule.type,\n                        fingerprint,\n                        path: details.path,\n                        runtime: rt,\n                        ttl: results[idx].ttl,\n                        conclusion: results[idx].conclusion,\n                        reason: results[idx].reason,\n                    }, \"Local rule result:\");\n                }\n                catch (err) {\n                    log.error(\"Failure running rule: %s due to %s\", rule.type, errorMessage(err));\n                    results[idx] = new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleResult({\n                        ttl: 0,\n                        state: \"RUN\",\n                        conclusion: \"ERROR\",\n                        reason: new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetErrorReason(err),\n                    });\n                }\n                finally {\n                    logRulePerf();\n                }\n                if (results[idx].isDenied()) {\n                    const decision = new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetDenyDecision({\n                        ttl: results[idx].ttl,\n                        reason: results[idx].reason,\n                        results,\n                    });\n                    // Only a DENY decision is reported to avoid creating 2 entries for a\n                    // request. Upon ALLOW, the `decide` call will create an entry for the\n                    // request.\n                    client.report(context, details, decision, rules);\n                    // If we're not in DRY_RUN mode, we want to cache non-zero TTL results\n                    // and return this DENY decision.\n                    if (rule.mode !== \"DRY_RUN\") {\n                        if (results[idx].ttl > 0) {\n                            log.debug({\n                                fingerprint,\n                                conclusion: decision.conclusion,\n                                reason: decision.reason,\n                            }, \"Caching decision for %d seconds\", decision.ttl);\n                            blockCache.set(fingerprint, decision.reason, nowInSeconds() + decision.ttl);\n                        }\n                        return decision;\n                    }\n                    log.warn(`Dry run mode is enabled for \"%s\" rule. Overriding decision. Decision was: %s`, rule.type, decision.conclusion);\n                }\n            }\n        }\n        finally {\n            logLocalPerf();\n        }\n        // With no cached values, we take a decision remotely. We use a timeout to\n        // fail open.\n        const logRemotePerf = perf.measure(\"remote\");\n        try {\n            const logDediceApiPerf = perf.measure(\"decideApi\");\n            const decision = await client\n                .decide(context, details, rules)\n                .finally(() => {\n                logDediceApiPerf();\n            });\n            // If the decision is to block and we have a non-zero TTL, we cache the\n            // block locally\n            if (decision.isDenied() && decision.ttl > 0) {\n                log.debug(\"decide: Caching block locally for %d seconds\", decision.ttl);\n                blockCache.set(fingerprint, decision.reason, nowInSeconds() + decision.ttl);\n            }\n            return decision;\n        }\n        catch (err) {\n            log.error(\"Encountered problem getting remote decision: %s\", errorMessage(err));\n            const decision = new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetErrorDecision({\n                ttl: 0,\n                reason: new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetErrorReason(err),\n                results,\n            });\n            client.report(context, details, decision, rules);\n            return decision;\n        }\n        finally {\n            logRemotePerf();\n        }\n    }\n    // This is a separate function so it can be called recursively\n    function withRule(baseRules, rule) {\n        const rules = [...baseRules, ...rule].sort((a, b) => a.priority - b.priority);\n        return Object.freeze({\n            withRule(rule) {\n                return withRule(rules, rule);\n            },\n            async protect(ctx, request) {\n                return protect(rules, ctx, request);\n            },\n        });\n    }\n    return Object.freeze({\n        withRule(rule) {\n            return withRule(rootRules, rule);\n        },\n        async protect(ctx, request) {\n            return protect(rootRules, ctx, request);\n        },\n    });\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYXJjamV0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUE2TDtBQUM1SjtBQUM2QjtBQUNuQjtBQUNFO0FBQ0Q7QUFDRjs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsTUFBTTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsSUFBSSxnQkFBZ0IsU0FBUztBQUNuRjtBQUNBO0FBQ0Esc0RBQXNELElBQUksdUJBQXVCLGlCQUFpQjtBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELElBQUksdUJBQXVCLDBCQUEwQixNQUFNLGVBQWU7QUFDN0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsSUFBSSxHQUFHLElBQUk7QUFDdkM7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELElBQUk7QUFDdEQ7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLG9CQUFvQjtBQUMvQztBQUNBLHFCQUFxQiwwQkFBMEI7QUFDL0M7QUFDQSxxQ0FBcUMsS0FBSyxzQkFBc0IsSUFBSTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsS0FBSyxvQkFBb0Isa0JBQWtCO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsVUFBVSw2REFBNkQ7QUFDdkUsVUFBVSxtRUFBbUU7QUFDN0UsVUFBVSwyREFBMkQ7QUFDckU7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsVUFBVSxzREFBc0Q7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsVUFBVSxzREFBc0Q7QUFDaEUsVUFBVSxpRUFBaUU7QUFDM0U7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsVUFBVSxzREFBc0Q7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsVUFBVSxzREFBc0Q7QUFDaEUsVUFBVSxtRUFBbUU7QUFDN0U7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsVUFBVSxzREFBc0Q7QUFDaEUsVUFBVSw4REFBOEQ7QUFDeEUsVUFBVSw2REFBNkQ7QUFDdkUsVUFBVSxxRUFBcUU7QUFDL0UsVUFBVSw0REFBNEQ7QUFDdEU7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsVUFBVSxzREFBc0Q7QUFDaEUsVUFBVSw2REFBNkQ7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsVUFBVSx1RUFBdUU7QUFDakY7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsVUFBVSxzREFBc0Q7QUFDaEUsVUFBVSw4REFBOEQ7QUFDeEUsVUFBVSw2REFBNkQ7QUFDdkU7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLG9CQUFvQixzREFBc0Q7QUFDMUUsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixtREFBYztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtREFBYztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG1EQUFjO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDhEQUFnQjtBQUMvQztBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsK0RBQWlCO0FBQ3JELHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxnRUFBMkI7QUFDaEUsbUNBQW1DLHVFQUF5QjtBQUM1RDtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsK0JBQStCLDhEQUFnQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsK0JBQStCLDhEQUFnQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixxQ0FBcUMsT0FBTztBQUM1QyxxQ0FBcUMseURBQW9CO0FBQ3pEO0FBQ0EsK0JBQStCLDhEQUFnQjtBQUMvQztBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsK0RBQWlCLEdBQUcsZ0JBQWdCO0FBQ3hFLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsOERBQWdCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQywrREFBaUI7QUFDckQ7QUFDQSx5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxzREFBaUI7QUFDdEQ7QUFDQTtBQUNBLCtCQUErQiw4REFBZ0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLDZEQUFlO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsK0JBQStCLDhEQUFnQjtBQUMvQztBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsNkRBQWU7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxvQkFBb0I7QUFDdEU7QUFDQSxtQkFBbUIsZUFBZTtBQUNsQztBQUNBO0FBQ0E7QUFDQSxZQUFZLGFBQWE7QUFDekIsZUFBZSx3REFBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHVEQUFhO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGdFQUEyQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQixpQ0FBaUMsaUVBQW1CO0FBQ3BEO0FBQ0EsNEJBQTRCLCtEQUFpQixrQ0FBa0Msb0JBQW9CO0FBQ25HO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGlFQUFtQjtBQUNwRDtBQUNBLDRCQUE0QiwrREFBaUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG9CQUFvQjtBQUM5QztBQUNBLCtCQUErQiw4REFBZ0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDBEQUFZO0FBQ3hDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNEVBQWU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGdFQUFrQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLDhEQUFnQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsK0RBQWlCO0FBQ3pELHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsOERBQWdCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQywrREFBaUI7QUFDckQscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsZ0VBQWtCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxpRUFBbUI7QUFDcEQ7QUFDQSw0QkFBNEIsK0RBQWlCO0FBQzdDO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMOztBQUVzSSIsInNvdXJjZXMiOlsiRDpcXHByb2plY3RzXFxhdHNcXG5vZGVfbW9kdWxlc1xcYXJjamV0XFxpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBBcmNqZXRSdWxlUmVzdWx0LCBBcmNqZXRFcnJvclJlYXNvbiwgQXJjamV0U2Vuc2l0aXZlSW5mb1JlYXNvbiwgQXJjamV0RW1haWxSZWFzb24sIEFyY2pldEJvdFJlYXNvbiwgQXJjamV0RXJyb3JEZWNpc2lvbiwgQXJjamV0UmVhc29uLCBBcmNqZXREZW55RGVjaXNpb24gfSBmcm9tICdAYXJjamV0L3Byb3RvY29sJztcbmV4cG9ydCAqIGZyb20gJ0BhcmNqZXQvcHJvdG9jb2wnO1xuaW1wb3J0IHsgaXNSYXRlTGltaXRSdWxlIH0gZnJvbSAnQGFyY2pldC9wcm90b2NvbC9jb252ZXJ0LmpzJztcbmltcG9ydCAqIGFzIGFuYWx5emUgZnJvbSAnQGFyY2pldC9hbmFseXplJztcbmltcG9ydCAqIGFzIGR1cmF0aW9uIGZyb20gJ0BhcmNqZXQvZHVyYXRpb24nO1xuaW1wb3J0IEFyY2pldEhlYWRlcnMgZnJvbSAnQGFyY2pldC9oZWFkZXJzJztcbmltcG9ydCB7IHJ1bnRpbWUgfSBmcm9tICdAYXJjamV0L3J1bnRpbWUnO1xuXG5mdW5jdGlvbiBhc3NlcnQoY29uZGl0aW9uLCBtc2cpIHtcbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICB9XG59XG5mdW5jdGlvbiBub3dJblNlY29uZHMoKSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApO1xufVxuY2xhc3MgQ2FjaGUge1xuICAgIGV4cGlyZXM7XG4gICAgZGF0YTtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5leHBpcmVzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmRhdGEgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIGdldChrZXkpIHtcbiAgICAgICAgY29uc3QgdHRsID0gdGhpcy50dGwoa2V5KTtcbiAgICAgICAgaWYgKHR0bCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGEuZ2V0KGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBDbGVhbnVwIGlmIGV4cGlyZWRcbiAgICAgICAgICAgIHRoaXMuZXhwaXJlcy5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgIHRoaXMuZGF0YS5kZWxldGUoa2V5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXQoa2V5LCB2YWx1ZSwgZXhwaXJlc0F0KSB7XG4gICAgICAgIHRoaXMuZXhwaXJlcy5zZXQoa2V5LCBleHBpcmVzQXQpO1xuICAgICAgICB0aGlzLmRhdGEuc2V0KGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICB0dGwoa2V5KSB7XG4gICAgICAgIGNvbnN0IG5vdyA9IG5vd0luU2Vjb25kcygpO1xuICAgICAgICBjb25zdCBleHBpcmVzQXQgPSB0aGlzLmV4cGlyZXMuZ2V0KGtleSkgPz8gbm93O1xuICAgICAgICByZXR1cm4gZXhwaXJlc0F0IC0gbm93O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGVycm9yTWVzc2FnZShlcnIpIHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZXJyID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZXJyID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICBcIm1lc3NhZ2VcIiBpbiBlcnIgJiZcbiAgICAgICAgICAgIHR5cGVvZiBlcnIubWVzc2FnZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIGVyci5tZXNzYWdlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBcIlVua25vd24gcHJvYmxlbVwiO1xufVxuY29uc3Qga25vd25GaWVsZHMgPSBbXG4gICAgXCJpcFwiLFxuICAgIFwibWV0aG9kXCIsXG4gICAgXCJwcm90b2NvbFwiLFxuICAgIFwiaG9zdFwiLFxuICAgIFwicGF0aFwiLFxuICAgIFwiaGVhZGVyc1wiLFxuICAgIFwiYm9keVwiLFxuICAgIFwiZW1haWxcIixcbiAgICBcImNvb2tpZXNcIixcbiAgICBcInF1ZXJ5XCIsXG5dO1xuZnVuY3Rpb24gaXNVbmtub3duUmVxdWVzdFByb3BlcnR5KGtleSkge1xuICAgIHJldHVybiAha25vd25GaWVsZHMuaW5jbHVkZXMoa2V5KTtcbn1cbmZ1bmN0aW9uIGlzRW1haWxUeXBlKHR5cGUpIHtcbiAgICByZXR1cm4gKHR5cGUgPT09IFwiRlJFRVwiIHx8XG4gICAgICAgIHR5cGUgPT09IFwiRElTUE9TQUJMRVwiIHx8XG4gICAgICAgIHR5cGUgPT09IFwiTk9fTVhfUkVDT1JEU1wiIHx8XG4gICAgICAgIHR5cGUgPT09IFwiTk9fR1JBVkFUQVJcIiB8fFxuICAgICAgICB0eXBlID09PSBcIklOVkFMSURcIik7XG59XG5jbGFzcyBQZXJmb3JtYW5jZSB7XG4gICAgbG9nO1xuICAgIGNvbnN0cnVjdG9yKGxvZ2dlcikge1xuICAgICAgICB0aGlzLmxvZyA9IGxvZ2dlcjtcbiAgICB9XG4gICAgLy8gVE9ETygjMjAyMCk6IFdlIHNob3VsZCBuby1vcCB0aGlzIGlmIGxvZ2xldmVsIGlzIG5vdCBgZGVidWdgIHRvIGRvIGxlc3Mgd29ya1xuICAgIG1lYXN1cmUobGFiZWwpIHtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGVuZCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAgICAgY29uc3QgZGlmZiA9IGVuZCAtIHN0YXJ0O1xuICAgICAgICAgICAgdGhpcy5sb2cuZGVidWcoXCJMQVRFTkNZICVzOiAlc21zXCIsIGxhYmVsLCBkaWZmLnRvRml4ZWQoMykpO1xuICAgICAgICB9O1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRvU3RyaW5nKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgcmV0dXJuIGAke3ZhbHVlfWA7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwiYm9vbGVhblwiKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA/IFwidHJ1ZVwiIDogXCJmYWxzZVwiO1xuICAgIH1cbiAgICByZXR1cm4gXCI8dW5zdXBwb3J0ZWQgdmFsdWU+XCI7XG59XG4vLyBUaGlzIGlzIHRoZSBTeW1ib2wgdGhhdCBWZXJjZWwgZGVmaW5lcyBpbiB0aGVpciBpbmZyYXN0cnVjdHVyZSB0byBhY2Nlc3MgdGhlXG4vLyBDb250ZXh0ICh3aGVyZSBhdmFpbGFibGUpLiBUaGUgQ29udGV4dCBjYW4gY29udGFpbiB0aGUgYHdhaXRVbnRpbGAgZnVuY3Rpb24uXG4vLyBodHRwczovL2dpdGh1Yi5jb20vdmVyY2VsL3ZlcmNlbC9ibG9iLzkzMGQ3ZmI4OTJkYzI2ZjI0MGYyYjk1MGQ5NjM5MzFjNDVlMWU2NjEvcGFja2FnZXMvZnVuY3Rpb25zL3NyYy9nZXQtY29udGV4dC50cyNMNlxuY29uc3QgU1lNQk9MX0ZPUl9SRVFfQ09OVEVYVCA9IFN5bWJvbC5mb3IoXCJAdmVyY2VsL3JlcXVlc3QtY29udGV4dFwiKTtcbmZ1bmN0aW9uIGxvb2t1cFdhaXRVbnRpbCgpIHtcbiAgICBjb25zdCBmcm9tU3ltYm9sID0gZ2xvYmFsVGhpcztcbiAgICBpZiAodHlwZW9mIGZyb21TeW1ib2xbU1lNQk9MX0ZPUl9SRVFfQ09OVEVYVF0gPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgZnJvbVN5bWJvbFtTWU1CT0xfRk9SX1JFUV9DT05URVhUXSAhPT0gbnVsbCAmJlxuICAgICAgICBcImdldFwiIGluIGZyb21TeW1ib2xbU1lNQk9MX0ZPUl9SRVFfQ09OVEVYVF0gJiZcbiAgICAgICAgdHlwZW9mIGZyb21TeW1ib2xbU1lNQk9MX0ZPUl9SRVFfQ09OVEVYVF0uZ2V0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY29uc3QgdmVyY2VsQ3R4ID0gZnJvbVN5bWJvbFtTWU1CT0xfRk9SX1JFUV9DT05URVhUXS5nZXQoKTtcbiAgICAgICAgaWYgKHR5cGVvZiB2ZXJjZWxDdHggPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgICAgIHZlcmNlbEN0eCAhPT0gbnVsbCAmJlxuICAgICAgICAgICAgXCJ3YWl0VW50aWxcIiBpbiB2ZXJjZWxDdHggJiZcbiAgICAgICAgICAgIHR5cGVvZiB2ZXJjZWxDdHgud2FpdFVudGlsID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB2ZXJjZWxDdHgud2FpdFVudGlsO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gdG9BbmFseXplUmVxdWVzdChyZXF1ZXN0KSB7XG4gICAgY29uc3QgaGVhZGVycyA9IHt9O1xuICAgIGlmICh0eXBlb2YgcmVxdWVzdC5oZWFkZXJzICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHJlcXVlc3QuaGVhZGVycy5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgIGhlYWRlcnNba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIC4uLnJlcXVlc3QsXG4gICAgICAgIGhlYWRlcnMsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGV4dHJhUHJvcHMoZGV0YWlscykge1xuICAgIGNvbnN0IGV4dHJhID0gbmV3IE1hcCgpO1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGRldGFpbHMpKSB7XG4gICAgICAgIGlmIChpc1Vua25vd25SZXF1ZXN0UHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgZXh0cmEuc2V0KGtleSwgdG9TdHJpbmcodmFsdWUpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKGV4dHJhLmVudHJpZXMoKSk7XG59XG5mdW5jdGlvbiBjcmVhdGVUeXBlVmFsaWRhdG9yKC4uLnR5cGVzKSB7XG4gICAgcmV0dXJuIChrZXksIHZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IHR5cGVPZlZhbHVlID0gdHlwZW9mIHZhbHVlO1xuICAgICAgICBpZiAoIXR5cGVzLmluY2x1ZGVzKHR5cGVPZlZhbHVlKSkge1xuICAgICAgICAgICAgaWYgKHR5cGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCB0eXBlIGZvciBcXGAke2tleX1cXGAgLSBleHBlY3RlZCAke3R5cGVzWzBdfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIHR5cGUgZm9yIFxcYCR7a2V5fVxcYCAtIGV4cGVjdGVkIG9uZSBvZiAke3R5cGVzLmpvaW4oXCIsIFwiKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiBjcmVhdGVWYWx1ZVZhbGlkYXRvcihcbi8vIFRoaXMgdXNlcyB0eXBlcyB0byBlbnN1cmUgd2UgaGF2ZSBhdCBsZWFzdCAyIHZhbHVlc1xuLi4udmFsdWVzKSB7XG4gICAgcmV0dXJuIChrZXksIHZhbHVlKSA9PiB7XG4gICAgICAgIC8vIFdlIGNhc3QgdGhlIHZhbHVlcyB0byB1bmtub3duIGJlY2F1c2UgdGhlIG9wdGlvblZhbHVlIGlzbid0IGtub3duIGJ1dFxuICAgICAgICAvLyB3ZSBvbmx5IHdhbnQgdG8gdXNlIGB2YWx1ZXNgIG9uIHN0cmluZyBlbnVtZXJhdGlvbnNcbiAgICAgICAgaWYgKCF2YWx1ZXMuaW5jbHVkZXModmFsdWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgdmFsdWUgZm9yIFxcYCR7a2V5fVxcYCAtIGV4cGVjdGVkIG9uZSBvZiAke3ZhbHVlcy5tYXAoKHZhbHVlKSA9PiBgJyR7dmFsdWV9J2ApLmpvaW4oXCIsIFwiKX1gKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiBjcmVhdGVBcnJheVZhbGlkYXRvcih2YWxpZGF0ZSkge1xuICAgIHJldHVybiAoa2V5LCB2YWx1ZSkgPT4ge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2lkeCwgaXRlbV0gb2YgdmFsdWUuZW50cmllcygpKSB7XG4gICAgICAgICAgICAgICAgdmFsaWRhdGUoYCR7a2V5fVske2lkeH1dYCwgaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgdHlwZSBmb3IgXFxgJHtrZXl9XFxgIC0gZXhwZWN0ZWQgYW4gYXJyYXlgKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiBjcmVhdGVWYWxpZGF0b3IoeyBydWxlLCB2YWxpZGF0aW9ucywgfSkge1xuICAgIHJldHVybiAob3B0aW9ucykgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IHsga2V5LCB2YWxpZGF0ZSwgcmVxdWlyZWQgfSBvZiB2YWxpZGF0aW9ucykge1xuICAgICAgICAgICAgaWYgKHJlcXVpcmVkICYmICFPYmplY3QuaGFzT3duKG9wdGlvbnMsIGtleSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFxcYCR7cnVsZX1cXGAgb3B0aW9ucyBlcnJvcjogXFxgJHtrZXl9XFxgIGlzIHJlcXVpcmVkYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IG9wdGlvbnNba2V5XTtcbiAgICAgICAgICAgIC8vIFRoZSBgcmVxdWlyZWRgIGZsYWcgaXMgY2hlY2tlZCBhYm92ZSwgc28gdGhlc2Ugc2hvdWxkIG9ubHkgYmUgdmFsaWRhdGVkXG4gICAgICAgICAgICAvLyBpZiB0aGUgdmFsdWUgaXMgbm90IHVuZGVmaW5lZC5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFxcYCR7cnVsZX1cXGAgb3B0aW9ucyBlcnJvcjogJHtlcnJvck1lc3NhZ2UoZXJyKX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufVxuY29uc3QgdmFsaWRhdGVTdHJpbmcgPSBjcmVhdGVUeXBlVmFsaWRhdG9yKFwic3RyaW5nXCIpO1xuY29uc3QgdmFsaWRhdGVOdW1iZXIgPSBjcmVhdGVUeXBlVmFsaWRhdG9yKFwibnVtYmVyXCIpO1xuY29uc3QgdmFsaWRhdGVCb29sZWFuID0gY3JlYXRlVHlwZVZhbGlkYXRvcihcImJvb2xlYW5cIik7XG5jb25zdCB2YWxpZGF0ZUZ1bmN0aW9uID0gY3JlYXRlVHlwZVZhbGlkYXRvcihcImZ1bmN0aW9uXCIpO1xuY29uc3QgdmFsaWRhdGVTdHJpbmdPck51bWJlciA9IGNyZWF0ZVR5cGVWYWxpZGF0b3IoXCJzdHJpbmdcIiwgXCJudW1iZXJcIik7XG5jb25zdCB2YWxpZGF0ZVN0cmluZ0FycmF5ID0gY3JlYXRlQXJyYXlWYWxpZGF0b3IodmFsaWRhdGVTdHJpbmcpO1xuY29uc3QgdmFsaWRhdGVNb2RlID0gY3JlYXRlVmFsdWVWYWxpZGF0b3IoXCJMSVZFXCIsIFwiRFJZX1JVTlwiKTtcbmNvbnN0IHZhbGlkYXRlRW1haWxUeXBlcyA9IGNyZWF0ZUFycmF5VmFsaWRhdG9yKGNyZWF0ZVZhbHVlVmFsaWRhdG9yKFwiRElTUE9TQUJMRVwiLCBcIkZSRUVcIiwgXCJOT19NWF9SRUNPUkRTXCIsIFwiTk9fR1JBVkFUQVJcIiwgXCJJTlZBTElEXCIpKTtcbmNvbnN0IHZhbGlkYXRlVG9rZW5CdWNrZXRPcHRpb25zID0gY3JlYXRlVmFsaWRhdG9yKHtcbiAgICBydWxlOiBcInRva2VuQnVja2V0XCIsXG4gICAgdmFsaWRhdGlvbnM6IFtcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcIm1vZGVcIixcbiAgICAgICAgICAgIHJlcXVpcmVkOiBmYWxzZSxcbiAgICAgICAgICAgIHZhbGlkYXRlOiB2YWxpZGF0ZU1vZGUsXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJjaGFyYWN0ZXJpc3RpY3NcIixcbiAgICAgICAgICAgIHZhbGlkYXRlOiB2YWxpZGF0ZVN0cmluZ0FycmF5LFxuICAgICAgICAgICAgcmVxdWlyZWQ6IGZhbHNlLFxuICAgICAgICB9LFxuICAgICAgICB7IGtleTogXCJyZWZpbGxSYXRlXCIsIHJlcXVpcmVkOiB0cnVlLCB2YWxpZGF0ZTogdmFsaWRhdGVOdW1iZXIgfSxcbiAgICAgICAgeyBrZXk6IFwiaW50ZXJ2YWxcIiwgcmVxdWlyZWQ6IHRydWUsIHZhbGlkYXRlOiB2YWxpZGF0ZVN0cmluZ09yTnVtYmVyIH0sXG4gICAgICAgIHsga2V5OiBcImNhcGFjaXR5XCIsIHJlcXVpcmVkOiB0cnVlLCB2YWxpZGF0ZTogdmFsaWRhdGVOdW1iZXIgfSxcbiAgICBdLFxufSk7XG5jb25zdCB2YWxpZGF0ZUZpeGVkV2luZG93T3B0aW9ucyA9IGNyZWF0ZVZhbGlkYXRvcih7XG4gICAgcnVsZTogXCJmaXhlZFdpbmRvd1wiLFxuICAgIHZhbGlkYXRpb25zOiBbXG4gICAgICAgIHsga2V5OiBcIm1vZGVcIiwgcmVxdWlyZWQ6IGZhbHNlLCB2YWxpZGF0ZTogdmFsaWRhdGVNb2RlIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJjaGFyYWN0ZXJpc3RpY3NcIixcbiAgICAgICAgICAgIHZhbGlkYXRlOiB2YWxpZGF0ZVN0cmluZ0FycmF5LFxuICAgICAgICAgICAgcmVxdWlyZWQ6IGZhbHNlLFxuICAgICAgICB9LFxuICAgICAgICB7IGtleTogXCJtYXhcIiwgcmVxdWlyZWQ6IHRydWUsIHZhbGlkYXRlOiB2YWxpZGF0ZU51bWJlciB9LFxuICAgICAgICB7IGtleTogXCJ3aW5kb3dcIiwgcmVxdWlyZWQ6IHRydWUsIHZhbGlkYXRlOiB2YWxpZGF0ZVN0cmluZ09yTnVtYmVyIH0sXG4gICAgXSxcbn0pO1xuY29uc3QgdmFsaWRhdGVTbGlkaW5nV2luZG93T3B0aW9ucyA9IGNyZWF0ZVZhbGlkYXRvcih7XG4gICAgcnVsZTogXCJzbGlkaW5nV2luZG93XCIsXG4gICAgdmFsaWRhdGlvbnM6IFtcbiAgICAgICAgeyBrZXk6IFwibW9kZVwiLCByZXF1aXJlZDogZmFsc2UsIHZhbGlkYXRlOiB2YWxpZGF0ZU1vZGUgfSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBcImNoYXJhY3RlcmlzdGljc1wiLFxuICAgICAgICAgICAgdmFsaWRhdGU6IHZhbGlkYXRlU3RyaW5nQXJyYXksXG4gICAgICAgICAgICByZXF1aXJlZDogZmFsc2UsXG4gICAgICAgIH0sXG4gICAgICAgIHsga2V5OiBcIm1heFwiLCByZXF1aXJlZDogdHJ1ZSwgdmFsaWRhdGU6IHZhbGlkYXRlTnVtYmVyIH0sXG4gICAgICAgIHsga2V5OiBcImludGVydmFsXCIsIHJlcXVpcmVkOiB0cnVlLCB2YWxpZGF0ZTogdmFsaWRhdGVTdHJpbmdPck51bWJlciB9LFxuICAgIF0sXG59KTtcbmNvbnN0IHZhbGlkYXRlU2Vuc2l0aXZlSW5mb09wdGlvbnMgPSBjcmVhdGVWYWxpZGF0b3Ioe1xuICAgIHJ1bGU6IFwic2Vuc2l0aXZlSW5mb1wiLFxuICAgIHZhbGlkYXRpb25zOiBbXG4gICAgICAgIHsga2V5OiBcIm1vZGVcIiwgcmVxdWlyZWQ6IGZhbHNlLCB2YWxpZGF0ZTogdmFsaWRhdGVNb2RlIH0sXG4gICAgICAgIHsga2V5OiBcImFsbG93XCIsIHJlcXVpcmVkOiBmYWxzZSwgdmFsaWRhdGU6IHZhbGlkYXRlU3RyaW5nQXJyYXkgfSxcbiAgICAgICAgeyBrZXk6IFwiZGVueVwiLCByZXF1aXJlZDogZmFsc2UsIHZhbGlkYXRlOiB2YWxpZGF0ZVN0cmluZ0FycmF5IH0sXG4gICAgICAgIHsga2V5OiBcImNvbnRleHRXaW5kb3dTaXplXCIsIHJlcXVpcmVkOiBmYWxzZSwgdmFsaWRhdGU6IHZhbGlkYXRlTnVtYmVyIH0sXG4gICAgICAgIHsga2V5OiBcImRldGVjdFwiLCByZXF1aXJlZDogZmFsc2UsIHZhbGlkYXRlOiB2YWxpZGF0ZUZ1bmN0aW9uIH0sXG4gICAgXSxcbn0pO1xuY29uc3QgdmFsaWRhdGVFbWFpbE9wdGlvbnMgPSBjcmVhdGVWYWxpZGF0b3Ioe1xuICAgIHJ1bGU6IFwidmFsaWRhdGVFbWFpbFwiLFxuICAgIHZhbGlkYXRpb25zOiBbXG4gICAgICAgIHsga2V5OiBcIm1vZGVcIiwgcmVxdWlyZWQ6IGZhbHNlLCB2YWxpZGF0ZTogdmFsaWRhdGVNb2RlIH0sXG4gICAgICAgIHsga2V5OiBcImJsb2NrXCIsIHJlcXVpcmVkOiBmYWxzZSwgdmFsaWRhdGU6IHZhbGlkYXRlRW1haWxUeXBlcyB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwicmVxdWlyZVRvcExldmVsRG9tYWluXCIsXG4gICAgICAgICAgICByZXF1aXJlZDogZmFsc2UsXG4gICAgICAgICAgICB2YWxpZGF0ZTogdmFsaWRhdGVCb29sZWFuLFxuICAgICAgICB9LFxuICAgICAgICB7IGtleTogXCJhbGxvd0RvbWFpbkxpdGVyYWxcIiwgcmVxdWlyZWQ6IGZhbHNlLCB2YWxpZGF0ZTogdmFsaWRhdGVCb29sZWFuIH0sXG4gICAgXSxcbn0pO1xuY29uc3QgdmFsaWRhdGVCb3RPcHRpb25zID0gY3JlYXRlVmFsaWRhdG9yKHtcbiAgICBydWxlOiBcImRldGVjdEJvdFwiLFxuICAgIHZhbGlkYXRpb25zOiBbXG4gICAgICAgIHsga2V5OiBcIm1vZGVcIiwgcmVxdWlyZWQ6IGZhbHNlLCB2YWxpZGF0ZTogdmFsaWRhdGVNb2RlIH0sXG4gICAgICAgIHsga2V5OiBcImFsbG93XCIsIHJlcXVpcmVkOiBmYWxzZSwgdmFsaWRhdGU6IHZhbGlkYXRlU3RyaW5nQXJyYXkgfSxcbiAgICAgICAgeyBrZXk6IFwiZGVueVwiLCByZXF1aXJlZDogZmFsc2UsIHZhbGlkYXRlOiB2YWxpZGF0ZVN0cmluZ0FycmF5IH0sXG4gICAgXSxcbn0pO1xuY29uc3QgdmFsaWRhdGVTaGllbGRPcHRpb25zID0gY3JlYXRlVmFsaWRhdG9yKHtcbiAgICBydWxlOiBcInNoaWVsZFwiLFxuICAgIHZhbGlkYXRpb25zOiBbeyBrZXk6IFwibW9kZVwiLCByZXF1aXJlZDogZmFsc2UsIHZhbGlkYXRlOiB2YWxpZGF0ZU1vZGUgfV0sXG59KTtcbmNvbnN0IFByaW9yaXR5ID0ge1xuICAgIFNlbnNpdGl2ZUluZm86IDEsXG4gICAgU2hpZWxkOiAyLFxuICAgIFJhdGVMaW1pdDogMyxcbiAgICBCb3REZXRlY3Rpb246IDQsXG4gICAgRW1haWxWYWxpZGF0aW9uOiA1LFxufTtcbmZ1bmN0aW9uIGlzTG9jYWxSdWxlKHJ1bGUpIHtcbiAgICByZXR1cm4gKFwidmFsaWRhdGVcIiBpbiBydWxlICYmXG4gICAgICAgIHR5cGVvZiBydWxlLnZhbGlkYXRlID09PSBcImZ1bmN0aW9uXCIgJiZcbiAgICAgICAgXCJwcm90ZWN0XCIgaW4gcnVsZSAmJlxuICAgICAgICB0eXBlb2YgcnVsZS5wcm90ZWN0ID09PSBcImZ1bmN0aW9uXCIpO1xufVxuZnVuY3Rpb24gdG9rZW5CdWNrZXQob3B0aW9ucykge1xuICAgIHZhbGlkYXRlVG9rZW5CdWNrZXRPcHRpb25zKG9wdGlvbnMpO1xuICAgIGNvbnN0IG1vZGUgPSBvcHRpb25zLm1vZGUgPT09IFwiTElWRVwiID8gXCJMSVZFXCIgOiBcIkRSWV9SVU5cIjtcbiAgICBjb25zdCBjaGFyYWN0ZXJpc3RpY3MgPSBvcHRpb25zLmNoYXJhY3RlcmlzdGljcztcbiAgICBjb25zdCByZWZpbGxSYXRlID0gb3B0aW9ucy5yZWZpbGxSYXRlO1xuICAgIGNvbnN0IGludGVydmFsID0gZHVyYXRpb24ucGFyc2Uob3B0aW9ucy5pbnRlcnZhbCk7XG4gICAgY29uc3QgY2FwYWNpdHkgPSBvcHRpb25zLmNhcGFjaXR5O1xuICAgIHJldHVybiBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIHR5cGU6IFwiUkFURV9MSU1JVFwiLFxuICAgICAgICAgICAgcHJpb3JpdHk6IFByaW9yaXR5LlJhdGVMaW1pdCxcbiAgICAgICAgICAgIG1vZGUsXG4gICAgICAgICAgICBjaGFyYWN0ZXJpc3RpY3MsXG4gICAgICAgICAgICBhbGdvcml0aG06IFwiVE9LRU5fQlVDS0VUXCIsXG4gICAgICAgICAgICByZWZpbGxSYXRlLFxuICAgICAgICAgICAgaW50ZXJ2YWwsXG4gICAgICAgICAgICBjYXBhY2l0eSxcbiAgICAgICAgfSxcbiAgICBdO1xufVxuZnVuY3Rpb24gZml4ZWRXaW5kb3cob3B0aW9ucykge1xuICAgIHZhbGlkYXRlRml4ZWRXaW5kb3dPcHRpb25zKG9wdGlvbnMpO1xuICAgIGNvbnN0IG1vZGUgPSBvcHRpb25zLm1vZGUgPT09IFwiTElWRVwiID8gXCJMSVZFXCIgOiBcIkRSWV9SVU5cIjtcbiAgICBjb25zdCBjaGFyYWN0ZXJpc3RpY3MgPSBBcnJheS5pc0FycmF5KG9wdGlvbnMuY2hhcmFjdGVyaXN0aWNzKVxuICAgICAgICA/IG9wdGlvbnMuY2hhcmFjdGVyaXN0aWNzXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IG1heCA9IG9wdGlvbnMubWF4O1xuICAgIGNvbnN0IHdpbmRvdyA9IGR1cmF0aW9uLnBhcnNlKG9wdGlvbnMud2luZG93KTtcbiAgICByZXR1cm4gW1xuICAgICAgICB7XG4gICAgICAgICAgICB0eXBlOiBcIlJBVEVfTElNSVRcIixcbiAgICAgICAgICAgIHByaW9yaXR5OiBQcmlvcml0eS5SYXRlTGltaXQsXG4gICAgICAgICAgICBtb2RlLFxuICAgICAgICAgICAgY2hhcmFjdGVyaXN0aWNzLFxuICAgICAgICAgICAgYWxnb3JpdGhtOiBcIkZJWEVEX1dJTkRPV1wiLFxuICAgICAgICAgICAgbWF4LFxuICAgICAgICAgICAgd2luZG93LFxuICAgICAgICB9LFxuICAgIF07XG59XG5mdW5jdGlvbiBzbGlkaW5nV2luZG93KG9wdGlvbnMpIHtcbiAgICB2YWxpZGF0ZVNsaWRpbmdXaW5kb3dPcHRpb25zKG9wdGlvbnMpO1xuICAgIGNvbnN0IG1vZGUgPSBvcHRpb25zLm1vZGUgPT09IFwiTElWRVwiID8gXCJMSVZFXCIgOiBcIkRSWV9SVU5cIjtcbiAgICBjb25zdCBjaGFyYWN0ZXJpc3RpY3MgPSBBcnJheS5pc0FycmF5KG9wdGlvbnMuY2hhcmFjdGVyaXN0aWNzKVxuICAgICAgICA/IG9wdGlvbnMuY2hhcmFjdGVyaXN0aWNzXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IG1heCA9IG9wdGlvbnMubWF4O1xuICAgIGNvbnN0IGludGVydmFsID0gZHVyYXRpb24ucGFyc2Uob3B0aW9ucy5pbnRlcnZhbCk7XG4gICAgcmV0dXJuIFtcbiAgICAgICAge1xuICAgICAgICAgICAgdHlwZTogXCJSQVRFX0xJTUlUXCIsXG4gICAgICAgICAgICBwcmlvcml0eTogUHJpb3JpdHkuUmF0ZUxpbWl0LFxuICAgICAgICAgICAgbW9kZSxcbiAgICAgICAgICAgIGNoYXJhY3RlcmlzdGljcyxcbiAgICAgICAgICAgIGFsZ29yaXRobTogXCJTTElESU5HX1dJTkRPV1wiLFxuICAgICAgICAgICAgbWF4LFxuICAgICAgICAgICAgaW50ZXJ2YWwsXG4gICAgICAgIH0sXG4gICAgXTtcbn1cbmZ1bmN0aW9uIHByb3RvY29sU2Vuc2l0aXZlSW5mb0VudGl0aWVzVG9BbmFseXplKGVudGl0eSkge1xuICAgIGlmICh0eXBlb2YgZW50aXR5ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgZW50aXR5IHR5cGVcIik7XG4gICAgfVxuICAgIGlmIChlbnRpdHkgPT09IFwiRU1BSUxcIikge1xuICAgICAgICByZXR1cm4geyB0YWc6IFwiZW1haWxcIiB9O1xuICAgIH1cbiAgICBpZiAoZW50aXR5ID09PSBcIlBIT05FX05VTUJFUlwiKSB7XG4gICAgICAgIHJldHVybiB7IHRhZzogXCJwaG9uZS1udW1iZXJcIiB9O1xuICAgIH1cbiAgICBpZiAoZW50aXR5ID09PSBcIklQX0FERFJFU1NcIikge1xuICAgICAgICByZXR1cm4geyB0YWc6IFwiaXAtYWRkcmVzc1wiIH07XG4gICAgfVxuICAgIGlmIChlbnRpdHkgPT09IFwiQ1JFRElUX0NBUkRfTlVNQkVSXCIpIHtcbiAgICAgICAgcmV0dXJuIHsgdGFnOiBcImNyZWRpdC1jYXJkLW51bWJlclwiIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHRhZzogXCJjdXN0b21cIixcbiAgICAgICAgdmFsOiBlbnRpdHksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGFuYWx5emVTZW5zaXRpdmVJbmZvRW50aXRpZXNUb1N0cmluZyhlbnRpdHkpIHtcbiAgICBpZiAoZW50aXR5LnRhZyA9PT0gXCJlbWFpbFwiKSB7XG4gICAgICAgIHJldHVybiBcIkVNQUlMXCI7XG4gICAgfVxuICAgIGlmIChlbnRpdHkudGFnID09PSBcImlwLWFkZHJlc3NcIikge1xuICAgICAgICByZXR1cm4gXCJJUF9BRERSRVNTXCI7XG4gICAgfVxuICAgIGlmIChlbnRpdHkudGFnID09PSBcImNyZWRpdC1jYXJkLW51bWJlclwiKSB7XG4gICAgICAgIHJldHVybiBcIkNSRURJVF9DQVJEX05VTUJFUlwiO1xuICAgIH1cbiAgICBpZiAoZW50aXR5LnRhZyA9PT0gXCJwaG9uZS1udW1iZXJcIikge1xuICAgICAgICByZXR1cm4gXCJQSE9ORV9OVU1CRVJcIjtcbiAgICB9XG4gICAgcmV0dXJuIGVudGl0eS52YWw7XG59XG5mdW5jdGlvbiBjb252ZXJ0QW5hbHl6ZURldGVjdGVkU2Vuc2l0aXZlSW5mb0VudGl0eShkZXRlY3RlZEVudGl0aWVzKSB7XG4gICAgcmV0dXJuIGRldGVjdGVkRW50aXRpZXMubWFwKChkZXRlY3RlZEVudGl0eSkgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uZGV0ZWN0ZWRFbnRpdHksXG4gICAgICAgICAgICBpZGVudGlmaWVkVHlwZTogYW5hbHl6ZVNlbnNpdGl2ZUluZm9FbnRpdGllc1RvU3RyaW5nKGRldGVjdGVkRW50aXR5LmlkZW50aWZpZWRUeXBlKSxcbiAgICAgICAgfTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHNlbnNpdGl2ZUluZm8ob3B0aW9ucykge1xuICAgIHZhbGlkYXRlU2Vuc2l0aXZlSW5mb09wdGlvbnMob3B0aW9ucyk7XG4gICAgY29uc3QgbW9kZSA9IG9wdGlvbnMubW9kZSA9PT0gXCJMSVZFXCIgPyBcIkxJVkVcIiA6IFwiRFJZX1JVTlwiO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5hbGxvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICB0eXBlb2Ygb3B0aW9ucy5kZW55ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImBzZW5zaXRpdmVJbmZvYCBvcHRpb25zIGVycm9yOiBgYWxsb3dgIGFuZCBgZGVueWAgY2Fubm90IGJlIHByb3ZpZGVkIHRvZ2V0aGVyXCIpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuYWxsb3cgPT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgdHlwZW9mIG9wdGlvbnMuZGVueSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJgc2Vuc2l0aXZlSW5mb2Agb3B0aW9ucyBlcnJvcjogZWl0aGVyIGBhbGxvd2Agb3IgYGRlbnlgIG11c3QgYmUgc3BlY2lmaWVkXCIpO1xuICAgIH1cbiAgICByZXR1cm4gW1xuICAgICAgICB7XG4gICAgICAgICAgICB0eXBlOiBcIlNFTlNJVElWRV9JTkZPXCIsXG4gICAgICAgICAgICBwcmlvcml0eTogUHJpb3JpdHkuU2Vuc2l0aXZlSW5mbyxcbiAgICAgICAgICAgIG1vZGUsXG4gICAgICAgICAgICBhbGxvdzogb3B0aW9ucy5hbGxvdyB8fCBbXSxcbiAgICAgICAgICAgIGRlbnk6IG9wdGlvbnMuZGVueSB8fCBbXSxcbiAgICAgICAgICAgIHZhbGlkYXRlKGNvbnRleHQsIGRldGFpbHMpIHsgfSxcbiAgICAgICAgICAgIGFzeW5jIHByb3RlY3QoY29udGV4dCwgZGV0YWlscykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBhd2FpdCBjb250ZXh0LmdldEJvZHkoKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGJvZHkgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBcmNqZXRSdWxlUmVzdWx0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR0bDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlOiBcIk5PVF9SVU5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmNsdXNpb246IFwiRVJST1JcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbjogbmV3IEFyY2pldEVycm9yUmVhc29uKFwiQ291bGRuJ3QgcmVhZCB0aGUgYm9keSBvZiB0aGUgcmVxdWVzdCB0byBwZXJmb3JtIHNlbnNpdGl2ZSBpbmZvIGlkZW50aWZpY2F0aW9uLlwiKSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBjb252ZXJ0ZWREZXRlY3QgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmRldGVjdCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkZXRlY3QgPSBvcHRpb25zLmRldGVjdDtcbiAgICAgICAgICAgICAgICAgICAgY29udmVydGVkRGV0ZWN0ID0gKHRva2VucykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRldGVjdCh0b2tlbnMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcigoZSkgPT4gdHlwZW9mIGUgIT09IFwidW5kZWZpbmVkXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChwcm90b2NvbFNlbnNpdGl2ZUluZm9FbnRpdGllc1RvQW5hbHl6ZSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBlbnRpdGllc1RhZyA9IFwiYWxsb3dcIjtcbiAgICAgICAgICAgICAgICBsZXQgZW50aXRpZXNWYWwgPSBbXTtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zLmFsbG93KSkge1xuICAgICAgICAgICAgICAgICAgICBlbnRpdGllc1RhZyA9IFwiYWxsb3dcIjtcbiAgICAgICAgICAgICAgICAgICAgZW50aXRpZXNWYWwgPSBvcHRpb25zLmFsbG93XG4gICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKChlKSA9PiB0eXBlb2YgZSAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAocHJvdG9jb2xTZW5zaXRpdmVJbmZvRW50aXRpZXNUb0FuYWx5emUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zLmRlbnkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGVudGl0aWVzVGFnID0gXCJkZW55XCI7XG4gICAgICAgICAgICAgICAgICAgIGVudGl0aWVzVmFsID0gb3B0aW9ucy5kZW55XG4gICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKChlKSA9PiB0eXBlb2YgZSAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAocHJvdG9jb2xTZW5zaXRpdmVJbmZvRW50aXRpZXNUb0FuYWx5emUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBlbnRpdGllcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgdGFnOiBlbnRpdGllc1RhZyxcbiAgICAgICAgICAgICAgICAgICAgdmFsOiBlbnRpdGllc1ZhbCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGFuYWx5emUuZGV0ZWN0U2Vuc2l0aXZlSW5mbyhjb250ZXh0LCBib2R5LCBlbnRpdGllcywgb3B0aW9ucy5jb250ZXh0V2luZG93U2l6ZSB8fCAxLCBjb252ZXJ0ZWREZXRlY3QpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlYXNvbiA9IG5ldyBBcmNqZXRTZW5zaXRpdmVJbmZvUmVhc29uKHtcbiAgICAgICAgICAgICAgICAgICAgZGVuaWVkOiBjb252ZXJ0QW5hbHl6ZURldGVjdGVkU2Vuc2l0aXZlSW5mb0VudGl0eShyZXN1bHQuZGVuaWVkKSxcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dlZDogY29udmVydEFuYWx5emVEZXRlY3RlZFNlbnNpdGl2ZUluZm9FbnRpdHkocmVzdWx0LmFsbG93ZWQpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuZGVuaWVkLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFyY2pldFJ1bGVSZXN1bHQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHRsOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGU6IFwiUlVOXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25jbHVzaW9uOiBcIkFMTE9XXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICByZWFzb24sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBcmNqZXRSdWxlUmVzdWx0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR0bDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlOiBcIlJVTlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uY2x1c2lvbjogXCJERU5ZXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICByZWFzb24sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgXTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlRW1haWwob3B0aW9ucykge1xuICAgIHZhbGlkYXRlRW1haWxPcHRpb25zKG9wdGlvbnMpO1xuICAgIGNvbnN0IG1vZGUgPSBvcHRpb25zLm1vZGUgPT09IFwiTElWRVwiID8gXCJMSVZFXCIgOiBcIkRSWV9SVU5cIjtcbiAgICBjb25zdCBibG9jayA9IG9wdGlvbnMuYmxvY2sgPz8gW107XG4gICAgY29uc3QgcmVxdWlyZVRvcExldmVsRG9tYWluID0gb3B0aW9ucy5yZXF1aXJlVG9wTGV2ZWxEb21haW4gPz8gdHJ1ZTtcbiAgICBjb25zdCBhbGxvd0RvbWFpbkxpdGVyYWwgPSBvcHRpb25zLmFsbG93RG9tYWluTGl0ZXJhbCA/PyBmYWxzZTtcbiAgICBjb25zdCBlbWFpbE9wdHMgPSB7XG4gICAgICAgIHJlcXVpcmVUb3BMZXZlbERvbWFpbixcbiAgICAgICAgYWxsb3dEb21haW5MaXRlcmFsLFxuICAgICAgICBibG9ja2VkRW1haWxzOiBibG9jayxcbiAgICB9O1xuICAgIHJldHVybiBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIHR5cGU6IFwiRU1BSUxcIixcbiAgICAgICAgICAgIHByaW9yaXR5OiBQcmlvcml0eS5FbWFpbFZhbGlkYXRpb24sXG4gICAgICAgICAgICBtb2RlLFxuICAgICAgICAgICAgYmxvY2ssXG4gICAgICAgICAgICByZXF1aXJlVG9wTGV2ZWxEb21haW4sXG4gICAgICAgICAgICBhbGxvd0RvbWFpbkxpdGVyYWwsXG4gICAgICAgICAgICB2YWxpZGF0ZShjb250ZXh0LCBkZXRhaWxzKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0KHR5cGVvZiBkZXRhaWxzLmVtYWlsICE9PSBcInVuZGVmaW5lZFwiLCBcIlZhbGlkYXRlRW1haWwgcmVxdWlyZXMgYGVtYWlsYCB0byBiZSBzZXQuXCIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFzeW5jIHByb3RlY3QoY29udGV4dCwgeyBlbWFpbCB9KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYW5hbHl6ZS5pc1ZhbGlkRW1haWwoY29udGV4dCwgZW1haWwsIGVtYWlsT3B0cyk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC52YWxpZGl0eSA9PT0gXCJ2YWxpZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQXJjamV0UnVsZVJlc3VsdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0dGw6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZTogXCJSVU5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmNsdXNpb246IFwiQUxMT1dcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbjogbmV3IEFyY2pldEVtYWlsUmVhc29uKHsgZW1haWxUeXBlczogW10gfSksXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHlwZWRFbWFpbFR5cGVzID0gcmVzdWx0LmJsb2NrZWQuZmlsdGVyKGlzRW1haWxUeXBlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBcmNqZXRSdWxlUmVzdWx0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR0bDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlOiBcIlJVTlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uY2x1c2lvbjogXCJERU5ZXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICByZWFzb246IG5ldyBBcmNqZXRFbWFpbFJlYXNvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZW1haWxUeXBlczogdHlwZWRFbWFpbFR5cGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgXTtcbn1cbmZ1bmN0aW9uIGRldGVjdEJvdChvcHRpb25zKSB7XG4gICAgdmFsaWRhdGVCb3RPcHRpb25zKG9wdGlvbnMpO1xuICAgIGNvbnN0IG1vZGUgPSBvcHRpb25zLm1vZGUgPT09IFwiTElWRVwiID8gXCJMSVZFXCIgOiBcIkRSWV9SVU5cIjtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuYWxsb3cgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgdHlwZW9mIG9wdGlvbnMuZGVueSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJgZGV0ZWN0Qm90YCBvcHRpb25zIGVycm9yOiBgYWxsb3dgIGFuZCBgZGVueWAgY2Fubm90IGJlIHByb3ZpZGVkIHRvZ2V0aGVyXCIpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuYWxsb3cgPT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgdHlwZW9mIG9wdGlvbnMuZGVueSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJgZGV0ZWN0Qm90YCBvcHRpb25zIGVycm9yOiBlaXRoZXIgYGFsbG93YCBvciBgZGVueWAgbXVzdCBiZSBzcGVjaWZpZWRcIik7XG4gICAgfVxuICAgIGxldCBjb25maWcgPSB7XG4gICAgICAgIHRhZzogXCJhbGxvd2VkLWJvdC1jb25maWdcIixcbiAgICAgICAgdmFsOiB7XG4gICAgICAgICAgICBlbnRpdGllczogW10sXG4gICAgICAgICAgICBza2lwQ3VzdG9tRGV0ZWN0OiB0cnVlLFxuICAgICAgICB9LFxuICAgIH07XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmFsbG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGNvbmZpZyA9IHtcbiAgICAgICAgICAgIHRhZzogXCJhbGxvd2VkLWJvdC1jb25maWdcIixcbiAgICAgICAgICAgIHZhbDoge1xuICAgICAgICAgICAgICAgIGVudGl0aWVzOiBvcHRpb25zLmFsbG93LFxuICAgICAgICAgICAgICAgIHNraXBDdXN0b21EZXRlY3Q6IHRydWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVueSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBjb25maWcgPSB7XG4gICAgICAgICAgICB0YWc6IFwiZGVuaWVkLWJvdC1jb25maWdcIixcbiAgICAgICAgICAgIHZhbDoge1xuICAgICAgICAgICAgICAgIGVudGl0aWVzOiBvcHRpb25zLmRlbnksXG4gICAgICAgICAgICAgICAgc2tpcEN1c3RvbURldGVjdDogdHJ1ZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIHR5cGU6IFwiQk9UXCIsXG4gICAgICAgICAgICBwcmlvcml0eTogUHJpb3JpdHkuQm90RGV0ZWN0aW9uLFxuICAgICAgICAgICAgbW9kZSxcbiAgICAgICAgICAgIGFsbG93OiBvcHRpb25zLmFsbG93ID8/IFtdLFxuICAgICAgICAgICAgZGVueTogb3B0aW9ucy5kZW55ID8/IFtdLFxuICAgICAgICAgICAgdmFsaWRhdGUoY29udGV4dCwgZGV0YWlscykge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGV0YWlscy5oZWFkZXJzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImJvdCBkZXRlY3Rpb24gcmVxdWlyZXMgYGhlYWRlcnNgIHRvIGJlIHNldFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkZXRhaWxzLmhlYWRlcnMuaGFzICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYm90IGRldGVjdGlvbiByZXF1aXJlcyBgaGVhZGVyc2AgdG8gZXh0ZW5kIGBIZWFkZXJzYFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFkZXRhaWxzLmhlYWRlcnMuaGFzKFwidXNlci1hZ2VudFwiKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJib3QgZGV0ZWN0aW9uIHJlcXVpcmVzIHVzZXItYWdlbnQgaGVhZGVyXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEF0dGVtcHRzIHRvIGNhbGwgdGhlIGJvdCBkZXRlY3Rpb24gb24gdGhlIGhlYWRlcnMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGFzeW5jIHByb3RlY3QoY29udGV4dCwgcmVxdWVzdCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGFuYWx5emUuZGV0ZWN0Qm90KGNvbnRleHQsIHRvQW5hbHl6ZVJlcXVlc3QocmVxdWVzdCksIGNvbmZpZyk7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyBhIGJvdCBhbmQgb2YgYSB0eXBlIHRoYXQgd2Ugd2FudCB0byBibG9jaywgdGhlbiBibG9jayFcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmRlbmllZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQXJjamV0UnVsZVJlc3VsdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0dGw6IDYwLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGU6IFwiUlVOXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25jbHVzaW9uOiBcIkRFTllcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbjogbmV3IEFyY2pldEJvdFJlYXNvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsb3dlZDogcmVzdWx0LmFsbG93ZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVuaWVkOiByZXN1bHQuZGVuaWVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZlcmlmaWVkOiByZXN1bHQudmVyaWZpZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Bvb2ZlZDogcmVzdWx0LnNwb29mZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFyY2pldFJ1bGVSZXN1bHQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHRsOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGU6IFwiUlVOXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25jbHVzaW9uOiBcIkFMTE9XXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICByZWFzb246IG5ldyBBcmNqZXRCb3RSZWFzb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93ZWQ6IHJlc3VsdC5hbGxvd2VkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbmllZDogcmVzdWx0LmRlbmllZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2ZXJpZmllZDogcmVzdWx0LnZlcmlmaWVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwb29mZWQ6IHJlc3VsdC5zcG9vZmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgXTtcbn1cbmZ1bmN0aW9uIHNoaWVsZChvcHRpb25zKSB7XG4gICAgdmFsaWRhdGVTaGllbGRPcHRpb25zKG9wdGlvbnMpO1xuICAgIGNvbnN0IG1vZGUgPSBvcHRpb25zLm1vZGUgPT09IFwiTElWRVwiID8gXCJMSVZFXCIgOiBcIkRSWV9SVU5cIjtcbiAgICByZXR1cm4gW1xuICAgICAgICB7XG4gICAgICAgICAgICB0eXBlOiBcIlNISUVMRFwiLFxuICAgICAgICAgICAgcHJpb3JpdHk6IFByaW9yaXR5LlNoaWVsZCxcbiAgICAgICAgICAgIG1vZGUsXG4gICAgICAgIH0sXG4gICAgXTtcbn1cbmZ1bmN0aW9uIHByb3RlY3RTaWdudXAob3B0aW9ucykge1xuICAgIHJldHVybiBbXG4gICAgICAgIC4uLnNsaWRpbmdXaW5kb3cob3B0aW9ucy5yYXRlTGltaXQpLFxuICAgICAgICAuLi5kZXRlY3RCb3Qob3B0aW9ucy5ib3RzKSxcbiAgICAgICAgLi4udmFsaWRhdGVFbWFpbChvcHRpb25zLmVtYWlsKSxcbiAgICBdO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgQXJjamV0IGNsaWVudCB3aXRoIHRoZSBzcGVjaWZpZWQge0BsaW5rIEFyY2pldE9wdGlvbnN9LlxuICpcbiAqIEBwYXJhbSBvcHRpb25zIHtBcmNqZXRPcHRpb25zfSBBcmNqZXQgY29uZmlndXJhdGlvbiBvcHRpb25zLlxuICovXG5mdW5jdGlvbiBhcmNqZXQob3B0aW9ucykge1xuICAgIC8vIFdlIGRlc3RydWN0dXJlIGhlcmUgdG8gbWFrZSB0aGUgZnVuY3Rpb24gc2lnbmF0dXJlIG5lYXQgd2hlbiB2aWV3ZWQgYnkgY29uc3VtZXJzXG4gICAgY29uc3QgeyBrZXksIHJ1bGVzIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IHJ0ID0gcnVudGltZSgpO1xuICAgIC8vIFRPRE86IFNlcGFyYXRlIHRoZSBBcmNqZXRPcHRpb25zIGZyb20gdGhlIFNESyBPcHRpb25zXG4gICAgLy8gSXQgaXMgY3VycmVudGx5IG9wdGlvbmFsIGluIHRoZSBvcHRpb25zIHNvIHVzZXJzIGNhbiBvdmVycmlkZSBpdCB2aWEgYW4gU0RLXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmxvZyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMb2cgaXMgcmVxdWlyZWRcIik7XG4gICAgfVxuICAgIGNvbnN0IGxvZyA9IG9wdGlvbnMubG9nO1xuICAgIGNvbnN0IHBlcmYgPSBuZXcgUGVyZm9ybWFuY2UobG9nKTtcbiAgICAvLyBUT0RPKCMyMDcpOiBSZW1vdmUgdGhpcyB3aGVuIHdlIGNhbiBkZWZhdWx0IHRoZSB0cmFuc3BvcnQgc28gY2xpZW50IGlzIG5vdCByZXF1aXJlZFxuICAgIC8vIEl0IGlzIGN1cnJlbnRseSBvcHRpb25hbCBpbiB0aGUgb3B0aW9ucyBzbyB0aGUgTmV4dCBTREsgY2FuIG92ZXJyaWRlIGl0IGZvciB0aGUgdXNlclxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5jbGllbnQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2xpZW50IGlzIHJlcXVpcmVkXCIpO1xuICAgIH1cbiAgICBjb25zdCBjbGllbnQgPSBvcHRpb25zLmNsaWVudDtcbiAgICAvLyBBIGxvY2FsIGNhY2hlIG9mIGJsb2NrIGRlY2lzaW9ucy4gTWlnaHQgYmUgZW1waGVtZXJhbCBwZXIgcmVxdWVzdCxcbiAgICAvLyBkZXBlbmRpbmcgb24gdGhlIHdheSB0aGUgcnVudGltZSB3b3JrcywgYnV0IGl0J3Mgd29ydGggYSB0cnkuXG4gICAgLy8gVE9ETygjMTMyKTogU3VwcG9ydCBjb25maWd1cmFibGUgY2FjaGluZ1xuICAgIGNvbnN0IGJsb2NrQ2FjaGUgPSBuZXcgQ2FjaGUoKTtcbiAgICBjb25zdCByb290UnVsZXMgPSBydWxlc1xuICAgICAgICAuZmxhdCgxKVxuICAgICAgICAuc29ydCgoYSwgYikgPT4gYS5wcmlvcml0eSAtIGIucHJpb3JpdHkpO1xuICAgIGFzeW5jIGZ1bmN0aW9uIHByb3RlY3QocnVsZXMsIGN0eCwgcmVxdWVzdCkge1xuICAgICAgICAvLyBUaGlzIGdvZXMgYWdhaW5zdCB0aGUgdHlwZSBkZWZpbml0aW9uIGFib3ZlLCBidXQgdXNlcnMgbWlnaHQgY2FsbFxuICAgICAgICAvLyBgcHJvdGVjdCgpYCB3aXRoIG5vIHZhbHVlIGFuZCB3ZSBkb24ndCB3YW50IHRvIGNyYXNoXG4gICAgICAgIGlmICh0eXBlb2YgcmVxdWVzdCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgcmVxdWVzdCA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRldGFpbHMgPSBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgICAgIGlwOiByZXF1ZXN0LmlwLFxuICAgICAgICAgICAgbWV0aG9kOiByZXF1ZXN0Lm1ldGhvZCxcbiAgICAgICAgICAgIHByb3RvY29sOiByZXF1ZXN0LnByb3RvY29sLFxuICAgICAgICAgICAgaG9zdDogcmVxdWVzdC5ob3N0LFxuICAgICAgICAgICAgcGF0aDogcmVxdWVzdC5wYXRoLFxuICAgICAgICAgICAgaGVhZGVyczogbmV3IEFyY2pldEhlYWRlcnMocmVxdWVzdC5oZWFkZXJzKSxcbiAgICAgICAgICAgIGNvb2tpZXM6IHJlcXVlc3QuY29va2llcyxcbiAgICAgICAgICAgIHF1ZXJ5OiByZXF1ZXN0LnF1ZXJ5LFxuICAgICAgICAgICAgLy8gVE9ETygjMjA4KTogUmUtYWRkIGJvZHlcbiAgICAgICAgICAgIC8vIGJvZHk6IHJlcXVlc3QuYm9keSxcbiAgICAgICAgICAgIGV4dHJhOiBleHRyYVByb3BzKHJlcXVlc3QpLFxuICAgICAgICAgICAgZW1haWw6IHR5cGVvZiByZXF1ZXN0LmVtYWlsID09PSBcInN0cmluZ1wiID8gcmVxdWVzdC5lbWFpbCA6IHVuZGVmaW5lZCxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGNoYXJhY3RlcmlzdGljcyA9IG9wdGlvbnMuY2hhcmFjdGVyaXN0aWNzXG4gICAgICAgICAgICA/IFsuLi5vcHRpb25zLmNoYXJhY3RlcmlzdGljc11cbiAgICAgICAgICAgIDogW107XG4gICAgICAgIGNvbnN0IHdhaXRVbnRpbCA9IGxvb2t1cFdhaXRVbnRpbCgpO1xuICAgICAgICBjb25zdCBiYXNlQ29udGV4dCA9IHtcbiAgICAgICAgICAgIGtleSxcbiAgICAgICAgICAgIGxvZyxcbiAgICAgICAgICAgIGNoYXJhY3RlcmlzdGljcyxcbiAgICAgICAgICAgIHdhaXRVbnRpbCxcbiAgICAgICAgICAgIC4uLmN0eCxcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGZpbmdlcnByaW50ID0gXCJcIjtcbiAgICAgICAgY29uc3QgbG9nRmluZ2VycHJpbnRQZXJmID0gcGVyZi5tZWFzdXJlKFwiZmluZ2VycHJpbnRcIik7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmaW5nZXJwcmludCA9IGF3YWl0IGFuYWx5emUuZ2VuZXJhdGVGaW5nZXJwcmludChiYXNlQ29udGV4dCwgdG9BbmFseXplUmVxdWVzdChkZXRhaWxzKSk7XG4gICAgICAgICAgICBsb2cuZGVidWcoXCJmaW5nZXJwcmludCAoJXMpOiAlc1wiLCBydCwgZmluZ2VycHJpbnQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgbG9nLmVycm9yKHsgZXJyb3IgfSwgXCJGYWlsZWQgdG8gYnVpbGQgZmluZ2VycHJpbnQuIFBsZWFzZSB2ZXJpZnkgeW91ciBDaGFyYWN0ZXJpc3RpY3MuXCIpO1xuICAgICAgICAgICAgY29uc3QgZGVjaXNpb24gPSBuZXcgQXJjamV0RXJyb3JEZWNpc2lvbih7XG4gICAgICAgICAgICAgICAgdHRsOiAwLFxuICAgICAgICAgICAgICAgIHJlYXNvbjogbmV3IEFyY2pldEVycm9yUmVhc29uKGBGYWlsZWQgdG8gYnVpbGQgZmluZ2VycHJpbnQgLSAke2Vycm9yTWVzc2FnZShlcnJvcil9YCksXG4gICAgICAgICAgICAgICAgLy8gTm8gcmVzdWx0cyBiZWNhdXNlIHdlIGNvdWxkbid0IGNyZWF0ZSBhIGZpbmdlcnByaW50XG4gICAgICAgICAgICAgICAgcmVzdWx0czogW10sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIFRPRE86IENvbnNpZGVyIHNlbmRpbmcgdGhpcyB0byBSZXBvcnQgd2hlbiB3ZSBoYXZlIGFuIGluZmFsbGlibGUgZmluZ2VycHJpbnRcbiAgICAgICAgICAgIHJldHVybiBkZWNpc2lvbjtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIGxvZ0ZpbmdlcnByaW50UGVyZigpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgICAgIC4uLmJhc2VDb250ZXh0LFxuICAgICAgICAgICAgZmluZ2VycHJpbnQsXG4gICAgICAgICAgICBydW50aW1lOiBydCxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChydWxlcy5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICAvLyBUT0RPKCM2MDcpOiBFcnJvciBpZiBubyBydWxlcyBjb25maWd1cmVkIGFmdGVyIGRlcHJlY2F0aW9uIHBlcmlvZFxuICAgICAgICAgICAgbG9nLndhcm4oXCJDYWxsaW5nIGBwcm90ZWN0KClgIHdpdGggbm8gcnVsZXMgaXMgZGVwcmVjYXRlZC4gRGlkIHlvdSBtZWFuIHRvIGNvbmZpZ3VyZSB0aGUgU2hpZWxkIHJ1bGU/XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChydWxlcy5sZW5ndGggPiAxMCkge1xuICAgICAgICAgICAgbG9nLmVycm9yKFwiRmFpbHVyZSBydW5uaW5nIHJ1bGVzLiBPbmx5IDEwIHJ1bGVzIG1heSBiZSBzcGVjaWZpZWQuXCIpO1xuICAgICAgICAgICAgY29uc3QgZGVjaXNpb24gPSBuZXcgQXJjamV0RXJyb3JEZWNpc2lvbih7XG4gICAgICAgICAgICAgICAgdHRsOiAwLFxuICAgICAgICAgICAgICAgIHJlYXNvbjogbmV3IEFyY2pldEVycm9yUmVhc29uKFwiT25seSAxMCBydWxlcyBtYXkgYmUgc3BlY2lmaWVkXCIpLFxuICAgICAgICAgICAgICAgIC8vIE5vIHJlc3VsdHMgYmVjYXVzZSB0aGUgc29ydGVkIHJ1bGVzIHdlcmUgdG9vIGxvbmcgYW5kIHdlIGRvbid0IHdhbnRcbiAgICAgICAgICAgICAgICAvLyB0byBpbnN0YW50aWF0ZSBhIHRvbiBvZiBOT1RfUlVOIHJlc3VsdHNcbiAgICAgICAgICAgICAgICByZXN1bHRzOiBbXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2xpZW50LnJlcG9ydChjb250ZXh0LCBkZXRhaWxzLCBkZWNpc2lvbiwgXG4gICAgICAgICAgICAvLyBObyBydWxlcyBiZWNhdXNlIHdlJ3ZlIGRldGVybWluZWQgdGhleSB3ZXJlIHRvbyBsb25nIGFuZCB3ZSBkb24ndFxuICAgICAgICAgICAgLy8gd2FudCB0byB0cnkgdG8gc2VuZCB0aGVtIHRvIHRoZSBzZXJ2ZXJcbiAgICAgICAgICAgIFtdKTtcbiAgICAgICAgICAgIHJldHVybiBkZWNpc2lvbjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IHJ1bGVzLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgICAgIC8vIERlZmF1bHQgYWxsIHJ1bGVzIHRvIE5PVF9SVU4vQUxMT1cgYmVmb3JlIGRvaW5nIGFueXRoaW5nXG4gICAgICAgICAgICByZXN1bHRzW2lkeF0gPSBuZXcgQXJjamV0UnVsZVJlc3VsdCh7XG4gICAgICAgICAgICAgICAgdHRsOiAwLFxuICAgICAgICAgICAgICAgIHN0YXRlOiBcIk5PVF9SVU5cIixcbiAgICAgICAgICAgICAgICBjb25jbHVzaW9uOiBcIkFMTE9XXCIsXG4gICAgICAgICAgICAgICAgcmVhc29uOiBuZXcgQXJjamV0UmVhc29uKCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIEFkZCB0b3AtbGV2ZWwgY2hhcmFjdGVyaXN0aWNzIHRvIGFsbCBSYXRlIExpbWl0IHJ1bGVzIHRoYXQgZG9uJ3QgYWxyZWFkeSBoYXZlXG4gICAgICAgICAgICAvLyB0aGVpciBvd24gc2V0IG9mIGNoYXJhY3RlcmlzdGljcy5cbiAgICAgICAgICAgIGNvbnN0IGNhbmRpZGF0ZV9ydWxlID0gcnVsZXNbaWR4XTtcbiAgICAgICAgICAgIGlmIChpc1JhdGVMaW1pdFJ1bGUoY2FuZGlkYXRlX3J1bGUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjYW5kaWRhdGVfcnVsZS5jaGFyYWN0ZXJpc3RpY3MgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FuZGlkYXRlX3J1bGUuY2hhcmFjdGVyaXN0aWNzID0gY2hhcmFjdGVyaXN0aWNzO1xuICAgICAgICAgICAgICAgICAgICBydWxlc1tpZHhdID0gY2FuZGlkYXRlX3J1bGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxvZ0xvY2FsUGVyZiA9IHBlcmYubWVhc3VyZShcImxvY2FsXCIpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2UgaGF2ZSBvdXIgb3duIGxvY2FsIGNhY2hlIHdoaWNoIHdlIGNoZWNrIGZpcnN0LiBUaGlzIGRvZXNuJ3Qgd29yayBpblxuICAgICAgICAgICAgLy8gc2VydmVybGVzcyBlbnZpcm9ubWVudHMgd2hlcmUgZXZlcnkgcmVxdWVzdCBpcyBpc29sYXRlZCwgYnV0IHRoZXJlIG1heSBiZVxuICAgICAgICAgICAgLy8gc29tZSBpbnN0YW5jZXMgd2hlcmUgdGhlIGluc3RhbmNlIGlzIG5vdCByZWN5Y2xlZCBpbW1lZGlhdGVseS4gSWYgc28sIHdlXG4gICAgICAgICAgICAvLyBjYW4gdGFrZSBhZHZhbnRhZ2Ugb2YgdGhhdC5cbiAgICAgICAgICAgIGNvbnN0IGxvZ0NhY2hlUGVyZiA9IHBlcmYubWVhc3VyZShcImNhY2hlXCIpO1xuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdCbG9ja1JlYXNvbiA9IGJsb2NrQ2FjaGUuZ2V0KGZpbmdlcnByaW50KTtcbiAgICAgICAgICAgIGxvZ0NhY2hlUGVyZigpO1xuICAgICAgICAgICAgLy8gSWYgYWxyZWFkeSBibG9ja2VkIHRoZW4gd2UgY2FuIGFzeW5jIGxvZyB0byB0aGUgQVBJIGFuZCByZXR1cm4gdGhlXG4gICAgICAgICAgICAvLyBkZWNpc2lvbiBpbW1lZGlhdGVseS5cbiAgICAgICAgICAgIGlmIChleGlzdGluZ0Jsb2NrUmVhc29uKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVjaXNpb24gPSBuZXcgQXJjamV0RGVueURlY2lzaW9uKHtcbiAgICAgICAgICAgICAgICAgICAgdHRsOiBibG9ja0NhY2hlLnR0bChmaW5nZXJwcmludCksXG4gICAgICAgICAgICAgICAgICAgIHJlYXNvbjogZXhpc3RpbmdCbG9ja1JlYXNvbixcbiAgICAgICAgICAgICAgICAgICAgLy8gQWxsIHJlc3VsdHMgd2lsbCBiZSBOT1RfUlVOIGJlY2F1c2Ugd2UgdXNlZCBhIGNhY2hlZCBkZWNpc2lvblxuICAgICAgICAgICAgICAgICAgICByZXN1bHRzLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNsaWVudC5yZXBvcnQoY29udGV4dCwgZGV0YWlscywgZGVjaXNpb24sIHJ1bGVzKTtcbiAgICAgICAgICAgICAgICBsb2cuZGVidWcoe1xuICAgICAgICAgICAgICAgICAgICBpZDogZGVjaXNpb24uaWQsXG4gICAgICAgICAgICAgICAgICAgIGNvbmNsdXNpb246IGRlY2lzaW9uLmNvbmNsdXNpb24sXG4gICAgICAgICAgICAgICAgICAgIGZpbmdlcnByaW50LFxuICAgICAgICAgICAgICAgICAgICByZWFzb246IGV4aXN0aW5nQmxvY2tSZWFzb24sXG4gICAgICAgICAgICAgICAgICAgIHJ1bnRpbWU6IHJ0LFxuICAgICAgICAgICAgICAgIH0sIFwiZGVjaWRlOiBhbHJlYWR5IGJsb2NrZWRcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlY2lzaW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBbaWR4LCBydWxlXSBvZiBydWxlcy5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIHJlLWFzc2lnbm1lbnQgaXMgYSB3b3JrYXJvdW5kIHRvIGEgVHlwZVNjcmlwdCBlcnJvciB3aXRoXG4gICAgICAgICAgICAgICAgLy8gYXNzZXJ0aW9ucyB3aGVyZSB0aGUgbmFtZSB3YXMgaW50cm9kdWNlZCB2aWEgYSBkZXN0cnVjdHVyZVxuICAgICAgICAgICAgICAgIGxldCBsb2NhbFJ1bGU7XG4gICAgICAgICAgICAgICAgaWYgKGlzTG9jYWxSdWxlKHJ1bGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsUnVsZSA9IHJ1bGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgbG9nUnVsZVBlcmYgPSBwZXJmLm1lYXN1cmUocnVsZS50eXBlKTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBsb2NhbFJ1bGUudmFsaWRhdGUoY29udGV4dCwgZGV0YWlscyk7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHNbaWR4XSA9IGF3YWl0IGxvY2FsUnVsZS5wcm90ZWN0KGNvbnRleHQsIGRldGFpbHMpO1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBhIHJ1bGUgZGlkbid0IHJldHVybiBhIHJ1bGUgcmVzdWx0LCB3ZSBuZWVkIHRvIHN0dWIgaXQgdG8gYXZvaWRcbiAgICAgICAgICAgICAgICAgICAgLy8gY3Jhc2hpbmcuIFRoaXMgc2hvdWxkIG9ubHkgaGFwcGVuIGlmIGEgdXNlciB3cml0ZXMgYSBjdXN0b20gbG9jYWxcbiAgICAgICAgICAgICAgICAgICAgLy8gcnVsZSBpbmNvcnJlY3RseS5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXN1bHRzW2lkeF0gPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHNbaWR4XSA9IG5ldyBBcmNqZXRSdWxlUmVzdWx0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0dGw6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGU6IFwiUlVOXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uY2x1c2lvbjogXCJFUlJPUlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbjogbmV3IEFyY2pldEVycm9yUmVhc29uKFwicnVsZSByZXN1bHQgbWlzc2luZ1wiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxvZy5kZWJ1Zyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogcmVzdWx0c1tpZHhdLnJ1bGVJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGU6IHJ1bGUudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmdlcnByaW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogZGV0YWlscy5wYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgcnVudGltZTogcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0dGw6IHJlc3VsdHNbaWR4XS50dGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25jbHVzaW9uOiByZXN1bHRzW2lkeF0uY29uY2x1c2lvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbjogcmVzdWx0c1tpZHhdLnJlYXNvbixcbiAgICAgICAgICAgICAgICAgICAgfSwgXCJMb2NhbCBydWxlIHJlc3VsdDpcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nLmVycm9yKFwiRmFpbHVyZSBydW5uaW5nIHJ1bGU6ICVzIGR1ZSB0byAlc1wiLCBydWxlLnR5cGUsIGVycm9yTWVzc2FnZShlcnIpKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1tpZHhdID0gbmV3IEFyY2pldFJ1bGVSZXN1bHQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHRsOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGU6IFwiUlVOXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25jbHVzaW9uOiBcIkVSUk9SXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICByZWFzb246IG5ldyBBcmNqZXRFcnJvclJlYXNvbihlcnIpLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ1J1bGVQZXJmKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHRzW2lkeF0uaXNEZW5pZWQoKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWNpc2lvbiA9IG5ldyBBcmNqZXREZW55RGVjaXNpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgdHRsOiByZXN1bHRzW2lkeF0udHRsLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVhc29uOiByZXN1bHRzW2lkeF0ucmVhc29uLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cyxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgYSBERU5ZIGRlY2lzaW9uIGlzIHJlcG9ydGVkIHRvIGF2b2lkIGNyZWF0aW5nIDIgZW50cmllcyBmb3IgYVxuICAgICAgICAgICAgICAgICAgICAvLyByZXF1ZXN0LiBVcG9uIEFMTE9XLCB0aGUgYGRlY2lkZWAgY2FsbCB3aWxsIGNyZWF0ZSBhbiBlbnRyeSBmb3IgdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlcXVlc3QuXG4gICAgICAgICAgICAgICAgICAgIGNsaWVudC5yZXBvcnQoY29udGV4dCwgZGV0YWlscywgZGVjaXNpb24sIHJ1bGVzKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgd2UncmUgbm90IGluIERSWV9SVU4gbW9kZSwgd2Ugd2FudCB0byBjYWNoZSBub24temVybyBUVEwgcmVzdWx0c1xuICAgICAgICAgICAgICAgICAgICAvLyBhbmQgcmV0dXJuIHRoaXMgREVOWSBkZWNpc2lvbi5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJ1bGUubW9kZSAhPT0gXCJEUllfUlVOXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHRzW2lkeF0udHRsID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZy5kZWJ1Zyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmdlcnByaW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25jbHVzaW9uOiBkZWNpc2lvbi5jb25jbHVzaW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFzb246IGRlY2lzaW9uLnJlYXNvbixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBcIkNhY2hpbmcgZGVjaXNpb24gZm9yICVkIHNlY29uZHNcIiwgZGVjaXNpb24udHRsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja0NhY2hlLnNldChmaW5nZXJwcmludCwgZGVjaXNpb24ucmVhc29uLCBub3dJblNlY29uZHMoKSArIGRlY2lzaW9uLnR0bCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVjaXNpb247XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbG9nLndhcm4oYERyeSBydW4gbW9kZSBpcyBlbmFibGVkIGZvciBcIiVzXCIgcnVsZS4gT3ZlcnJpZGluZyBkZWNpc2lvbi4gRGVjaXNpb24gd2FzOiAlc2AsIHJ1bGUudHlwZSwgZGVjaXNpb24uY29uY2x1c2lvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgbG9nTG9jYWxQZXJmKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2l0aCBubyBjYWNoZWQgdmFsdWVzLCB3ZSB0YWtlIGEgZGVjaXNpb24gcmVtb3RlbHkuIFdlIHVzZSBhIHRpbWVvdXQgdG9cbiAgICAgICAgLy8gZmFpbCBvcGVuLlxuICAgICAgICBjb25zdCBsb2dSZW1vdGVQZXJmID0gcGVyZi5tZWFzdXJlKFwicmVtb3RlXCIpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgbG9nRGVkaWNlQXBpUGVyZiA9IHBlcmYubWVhc3VyZShcImRlY2lkZUFwaVwiKTtcbiAgICAgICAgICAgIGNvbnN0IGRlY2lzaW9uID0gYXdhaXQgY2xpZW50XG4gICAgICAgICAgICAgICAgLmRlY2lkZShjb250ZXh0LCBkZXRhaWxzLCBydWxlcylcbiAgICAgICAgICAgICAgICAuZmluYWxseSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgbG9nRGVkaWNlQXBpUGVyZigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBJZiB0aGUgZGVjaXNpb24gaXMgdG8gYmxvY2sgYW5kIHdlIGhhdmUgYSBub24temVybyBUVEwsIHdlIGNhY2hlIHRoZVxuICAgICAgICAgICAgLy8gYmxvY2sgbG9jYWxseVxuICAgICAgICAgICAgaWYgKGRlY2lzaW9uLmlzRGVuaWVkKCkgJiYgZGVjaXNpb24udHRsID4gMCkge1xuICAgICAgICAgICAgICAgIGxvZy5kZWJ1ZyhcImRlY2lkZTogQ2FjaGluZyBibG9jayBsb2NhbGx5IGZvciAlZCBzZWNvbmRzXCIsIGRlY2lzaW9uLnR0bCk7XG4gICAgICAgICAgICAgICAgYmxvY2tDYWNoZS5zZXQoZmluZ2VycHJpbnQsIGRlY2lzaW9uLnJlYXNvbiwgbm93SW5TZWNvbmRzKCkgKyBkZWNpc2lvbi50dGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRlY2lzaW9uO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGxvZy5lcnJvcihcIkVuY291bnRlcmVkIHByb2JsZW0gZ2V0dGluZyByZW1vdGUgZGVjaXNpb246ICVzXCIsIGVycm9yTWVzc2FnZShlcnIpKTtcbiAgICAgICAgICAgIGNvbnN0IGRlY2lzaW9uID0gbmV3IEFyY2pldEVycm9yRGVjaXNpb24oe1xuICAgICAgICAgICAgICAgIHR0bDogMCxcbiAgICAgICAgICAgICAgICByZWFzb246IG5ldyBBcmNqZXRFcnJvclJlYXNvbihlcnIpLFxuICAgICAgICAgICAgICAgIHJlc3VsdHMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNsaWVudC5yZXBvcnQoY29udGV4dCwgZGV0YWlscywgZGVjaXNpb24sIHJ1bGVzKTtcbiAgICAgICAgICAgIHJldHVybiBkZWNpc2lvbjtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIGxvZ1JlbW90ZVBlcmYoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBUaGlzIGlzIGEgc2VwYXJhdGUgZnVuY3Rpb24gc28gaXQgY2FuIGJlIGNhbGxlZCByZWN1cnNpdmVseVxuICAgIGZ1bmN0aW9uIHdpdGhSdWxlKGJhc2VSdWxlcywgcnVsZSkge1xuICAgICAgICBjb25zdCBydWxlcyA9IFsuLi5iYXNlUnVsZXMsIC4uLnJ1bGVdLnNvcnQoKGEsIGIpID0+IGEucHJpb3JpdHkgLSBiLnByaW9yaXR5KTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5mcmVlemUoe1xuICAgICAgICAgICAgd2l0aFJ1bGUocnVsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB3aXRoUnVsZShydWxlcywgcnVsZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYXN5bmMgcHJvdGVjdChjdHgsIHJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvdGVjdChydWxlcywgY3R4LCByZXF1ZXN0KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIHdpdGhSdWxlKHJ1bGUpIHtcbiAgICAgICAgICAgIHJldHVybiB3aXRoUnVsZShyb290UnVsZXMsIHJ1bGUpO1xuICAgICAgICB9LFxuICAgICAgICBhc3luYyBwcm90ZWN0KGN0eCwgcmVxdWVzdCkge1xuICAgICAgICAgICAgcmV0dXJuIHByb3RlY3Qocm9vdFJ1bGVzLCBjdHgsIHJlcXVlc3QpO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuXG5leHBvcnQgeyBhcmNqZXQgYXMgZGVmYXVsdCwgZGV0ZWN0Qm90LCBmaXhlZFdpbmRvdywgcHJvdGVjdFNpZ251cCwgc2Vuc2l0aXZlSW5mbywgc2hpZWxkLCBzbGlkaW5nV2luZG93LCB0b2tlbkJ1Y2tldCwgdmFsaWRhdGVFbWFpbCB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/arcjet/index.js\n");

/***/ })

};
;